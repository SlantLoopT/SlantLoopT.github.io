<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-C++学习笔记/引用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%95%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2025-07-18T12:06:30.636Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%95%E7%94%A8/">引用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是已定义的变量的别名，主要用途是用作函数的形参和返回值。<br><strong>声明引用的语法：</strong> 数据类型 &amp;引用名&#x3D;原变量名;</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>引用的数据类型要与原变量名的数据类型相同。</li>
<li>引用名和原变量名可以互换，它们值和内存单元是相同的。</li>
<li>必须在声明引用的时候初始化，初始化后不可改变。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;          <span class="comment">// 声明普通的整型变量。</span></span><br><span class="line"><span class="type">int</span>&amp; ra = a;      <span class="comment">// 创建引用ra，ra是a的别名。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a  &lt;&lt; <span class="string">&quot;， a的值是：&quot;</span> &lt;&lt;  a  &lt;&lt; endl;     <span class="comment">// 输出 a的地址是：0x7ffc0b7c0c08， a的值是：3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra的值是：&quot;</span> &lt;&lt; ra &lt;&lt; endl;      <span class="comment">// 输出ra的地址是：0x7ffc0b7c0c08，ra的值是：3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">ra = b;     <span class="comment">// 注意这里，不是让ra作为b的引用，ra已经是a的引用不能改变，此处是将b的值赋值给a。 </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;， a的值是：&quot;</span> &lt;&lt; a &lt;&lt; endl;        <span class="comment">// 输出 a的地址是：0x7ffc0b7c0c08， a的值是：5</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra的值是：&quot;</span> &lt;&lt; ra &lt;&lt; endl;      <span class="comment">// 输出ra的地址是：0x7ffc0b7c0c08，ra的值是：5</span></span><br></pre></td></tr></table></figure>
<h4 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h4><p>引用是指针常量的伪装。<br>变量是什么？变量就是一个在程序执行过程中可以改变的量。<br>换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。<br>在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。<br>所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。<br>程序员拥有引用，但编译器仅拥有指针（地址）。<br>引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，编译器还是会把引用解释为指针。<br>引用和指针本质上没有区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;                 <span class="comment">// 声明普通的整型变量。</span></span><br><span class="line"><span class="type">int</span>&amp; ra = a;              <span class="comment">// 创建引用ra，ra是a的别名。               </span></span><br><span class="line"><span class="comment">// 把int&amp;替换成int* const   把a替换成&amp;a</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> rb = &amp;a;        <span class="comment">// 声明指针常量rb，让它指向变量a。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Address of a: &quot;</span> &lt;&lt; &amp;a  &lt;&lt; <span class="string">&quot;, Value of a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Address of ra: &quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;, Value of ra: &quot;</span> &lt;&lt; ra &lt;&lt; endl;     <span class="comment">// 把&amp;ra替换成ra，把ra替换成*ra</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of rb: &quot;</span> &lt;&lt; rb &lt;&lt; <span class="string">&quot;, Value of *rb: &quot;</span> &lt;&lt; *rb &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ra = <span class="number">5</span>;    </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Address of a: &quot;</span> &lt;&lt; &amp;a  &lt;&lt; <span class="string">&quot;, Value of a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Address of ra: &quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;, Value of ra: &quot;</span> &lt;&lt; ra &lt;&lt; endl;     </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of rb: &quot;</span> &lt;&lt; rb &lt;&lt; <span class="string">&quot;, Value of *rb: &quot;</span> &lt;&lt; *rb &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果全部相同：</span></span><br><span class="line"><span class="comment">Address of a: 0x65a4fff7bc, Value of a: 3</span></span><br><span class="line"><span class="comment">Address of ra: 0x65a4fff7bc, Value of ra: 3</span></span><br><span class="line"><span class="comment">Value of rb: 0x65a4fff7bc, Value of *rb: 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Address of a: 0x65a4fff7bc, Value of a: 5</span></span><br><span class="line"><span class="comment">Address of ra: 0x65a4fff7bc, Value of ra: 5</span></span><br><span class="line"><span class="comment">Value of rb: 0x65a4fff7bc, Value of *rb: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="引用用于函数的参数（引用传递）"><a href="#引用用于函数的参数（引用传递）" class="headerlink" title="引用用于函数的参数（引用传递）"></a>引用用于函数的参数（引用传递）</h4><p>把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名，引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。<br><strong>传引用的代码更简洁。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>      <span class="comment">// 定义超女结构体。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> no;            <span class="comment">// 超女编号。</span></span><br><span class="line">	string str;      <span class="comment">// 表白内容。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(st_girl girl)</span>    <span class="comment">// 传值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	girl.no = <span class="number">8</span>;</span><br><span class="line">	girl.str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; girl.no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; girl.str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(st_girl *girl)</span>    <span class="comment">// 传地址。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	girl-&gt;no = <span class="number">8</span>;</span><br><span class="line">	girl-&gt;str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; girl-&gt;no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; girl-&gt;str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(st_girl &amp; girl)</span>    <span class="comment">// 传引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	girl.no = <span class="number">8</span>;</span><br><span class="line">	girl.str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; girl.no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; girl.str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ist_girl girl = &#123; <span class="number">3</span>,<span class="string">&quot;我是一只傻傻鸟。&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func1</span>(girl);              <span class="comment">// 传值，不会影响实参。</span></span><br><span class="line">	<span class="built_in">func2</span>(&amp;girl);            <span class="comment">// 传地址，修改实参</span></span><br><span class="line">	<span class="built_in">func3</span>(girl);              <span class="comment">// 传引用，修改实参</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; girl.no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; girl.str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>传引用不必使用二级指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>** p)</span>      <span class="comment">// 传地址，实参是指针的地址，形参是二级指针。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);       <span class="comment">// p是二级指针，存放指针的地址。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func1内存的地址是：&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>*&amp; p)</span>     <span class="comment">// 传引用，实参是指针，形参是指针的别名。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);         <span class="comment">// p是指针的别名。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2内存的地址是：&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">nullptr</span>;    <span class="comment">// 存放在子函数中动态分配内存的地址。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">func1</span>(&amp;p);      <span class="comment">// 传地址，实参填指针p的地址。</span></span><br><span class="line">	<span class="built_in">func2</span>(p);      <span class="comment">// 传引用，实参填指针p。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main 内存的地址是：&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用的形参和const"><a href="#引用的形参和const" class="headerlink" title="引用的形参和const"></a>引用的形参和const</h4><p>如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量。</p>
<p><strong>为什么要将引用形参声明为const</strong></p>
<ul>
<li>使用const可以避免无意中修改数据的编程错误。</li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const实参。（可见const与引用和指针.md)</li>
<li>使用const，函数能正确生成并使用临时变量。</li>
</ul>
<p>左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。<br>非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。</p>
<p><strong>什么时候将创建临时变量？</strong></p>
<ul>
<li>引用是const。</li>
<li>数据对象的类型是正确的，但不是左值。</li>
<li>数据对象的类型不正确，但可以转换为正确的类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> no, string str)</span>    <span class="comment">// 传值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* no,<span class="type">const</span> string* str)</span>    <span class="comment">// 传地址。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; *no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func22</span><span class="params">( <span class="type">int</span>* no, string* str)</span>    <span class="comment">// 传地址。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; *no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; no, <span class="type">const</span> string&amp; str)</span>    <span class="comment">// 传引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func33</span><span class="params">( <span class="type">int</span>&amp; no,  string&amp; str)</span>    <span class="comment">// 传引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bh = <span class="number">3</span>;</span><br><span class="line">    string message = <span class="string">&quot;我是一只傻傻鸟。&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func1</span>(<span class="number">8</span>, <span class="string">&quot;我是一只小小鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">8</span>, <span class="string">&quot;我是一只小小鸟。&quot;</span>);   <span class="comment">// 报错，类型不兼容</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    指针没有这种创建临时变量的方式</span></span><br><span class="line"><span class="comment">    const int* no = 8;         // 无地址</span></span><br><span class="line"><span class="comment">    int tmp = 8;</span></span><br><span class="line"><span class="comment">    const int* no = &amp;tmp;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">func2</span>(&amp;bh, &amp;message);       <span class="comment">// 正确，常量指针可以指向变量也可以指向常量。</span></span><br><span class="line">    <span class="built_in">func22</span>(<span class="number">8</span>, <span class="string">&quot;我是一只小小鸟。&quot;</span>);  <span class="comment">// 报错，类型不兼容</span></span><br><span class="line">    <span class="built_in">func22</span>(&amp;bh, &amp;message);      <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func3</span>(<span class="string">&#x27;X&#x27;</span>, <span class="string">&quot;我是一只小小鸟。&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; no = <span class="string">&#x27;X&#x27;</span>;        <span class="comment">// &#x27;X&#x27;为char类型，可以转换为int。</span></span><br><span class="line">    <span class="comment">//等同于</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">int</span>(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; no = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func3</span>(<span class="string">&quot;字符串&quot;</span>, <span class="string">&quot;我是一只小小鸟。&quot;</span>);    <span class="comment">// 错误，类型无法转换string -&gt; int</span></span><br><span class="line">    <span class="built_in">func3</span>(bh, message);     <span class="comment">// 正确，常量引用可以指向变量也可以指向常量。</span></span><br><span class="line">    <span class="built_in">func33</span>(<span class="string">&#x27;X&#x27;</span>, <span class="string">&quot;我是一只小小鸟。&quot;</span>);    <span class="comment">// 错误，非const，无法创建临时变量</span></span><br><span class="line">    <span class="built_in">func33</span>(bh, message);    <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用用于函数的返回值"><a href="#引用用于函数的返回值" class="headerlink" title="引用用于函数的返回值"></a>引用用于函数的返回值</h4><p>传统的函数返回机制与值传递类似。<br>函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值。<br>如果返回的是一个结构体，将把整个结构体拷贝到临时的位置。<br>如果返回引用不会拷贝内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。</span></span><br><span class="line"><span class="type">double</span> m=<span class="built_in">sqrt</span>(<span class="number">36</span>);      </span><br></pre></td></tr></table></figure>
<p><strong>语法:</strong> 返回值的数据类型&amp; 函数名(形参列表);</p>
<h5 id="如果返回局部变量的引用，其本质是野指针，后果不可预知。"><a href="#如果返回局部变量的引用，其本质是野指针，后果不可预知。" class="headerlink" title="如果返回局部变量的引用，其本质是野指针，后果不可预知。"></a>如果返回局部变量的引用，其本质是野指针，后果不可预知。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; b = <span class="built_in">func</span>();		<span class="comment">// 函数func调用结束后，局部变量a将销毁，b将指向野指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可以返回函数的引用形参、类的成员、全局变量、静态变量。"><a href="#可以返回函数的引用形参、类的成员、全局变量、静态变量。" class="headerlink" title="可以返回函数的引用形参、类的成员、全局变量、静态变量。"></a>可以返回函数的引用形参、类的成员、全局变量、静态变量。</h5><p>引用形参本身就绑定到调用者传入的变量上，因此返回它们的引用是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">max</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;  <span class="comment">// 返回引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">max</span>(x, y) = <span class="number">100</span>;  <span class="comment">// 修改的是 x 或 y 中较大的一个</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出: 5 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是对象的成员变量的引用，只要对象还存在，这个引用就是有效的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) : <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;  <span class="comment">// 返回成员的引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">getAge</span>() = <span class="number">30</span>;  <span class="comment">// 修改成员变量</span></span><br><span class="line">    std::cout &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量生命周期贯穿整个程序，返回它的引用是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getGlobal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> global_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getGlobal</span>() = <span class="number">100</span>;  <span class="comment">// 修改全局变量</span></span><br><span class="line">    std::cout &lt;&lt; global_value &lt;&lt; std::endl;  <span class="comment">// 输出: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态变量在函数内只初始化一次，直到程序结束都存在，返回引用是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">staticCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">staticCounter</span>() = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">staticCounter</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="返回引用的函数是被引用的变量的别名，可将const用于引用的返回类型，防止调用者通过返回值修改被引用的变量。"><a href="#返回引用的函数是被引用的变量的别名，可将const用于引用的返回类型，防止调用者通过返回值修改被引用的变量。" class="headerlink" title="返回引用的函数是被引用的变量的别名，可将const用于引用的返回类型，防止调用者通过返回值修改被引用的变量。"></a>返回引用的函数是被引用的变量的别名，可将const用于引用的返回类型，防止调用者通过返回值修改被引用的变量。</h5><p>本质理解：返回引用的函数 &#x3D; 返回某个变量的别名<br>如果不加const，当函数返回引用时，允许调用者访问并修改那个变量本身。<br>如果返回类型是 const T&amp;，那么即使你返回的是可修改的变量，调用者也不能改了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getConstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getRef</span>() = <span class="number">20</span>;	 <span class="comment">// ✅ 可以修改 val</span></span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl; 	<span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getConstRef</span>() = <span class="number">20</span>;  <span class="comment">// ❌ 编译错误！不能通过 const 引用修改 val</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getConstRef</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: 10</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%95%E7%94%A8/" data-id="cmdohx9hb000430w8czb1d4d1" data-title="引用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/枚举" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time class="dt-published" datetime="2025-07-17T12:11:49.226Z" itemprop="datePublished">2025-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE/">枚举</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是一种创建符号常量的方法。<br><strong>枚举的语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123; 枚举量<span class="number">1</span> , 枚举量<span class="number">2</span> , 枚举量<span class="number">3</span>, ......, 枚举量n &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; red, blue, yellow &#125;;   <span class="comment">//将red、yellow、blue作为符号常量，默认值是整数的0、1、2。</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">colors</span> &#123; red, yellow, blue, other &#125;;    <span class="comment">// 创建枚举类型colors。</span></span><br><span class="line"></span><br><span class="line">	colors cc = yellow;           <span class="comment">// 创建枚举变量，并赋初始值。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;red=&quot;</span> &lt;&lt; red &lt;&lt; <span class="string">&quot;,yellow=&quot;</span> &lt;&lt; yellow &lt;&lt; <span class="string">&quot;,blue=&quot;</span> &lt;&lt; blue &lt;&lt; <span class="string">&quot;,other=&quot;</span> &lt;&lt; other &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> red:			cout &lt;&lt; <span class="string">&quot;红色。\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> yellow:	cout &lt;&lt; <span class="string">&quot;黄色。\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> blue:		cout &lt;&lt; <span class="string">&quot;蓝色。\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:			cout &lt;&lt; <span class="string">&quot;未知。\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>用枚举创建的变量取值只能在枚举量范围之内。</li>
<li>可以显式的设置枚举量的值（必须是整数）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">colors</span> &#123;red=<span class="number">1</span>,yellow=<span class="number">2</span>,blue=<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">colors</span> &#123;red,yellow,blue&#125;;      <span class="comment">// 默认值是0、1、2。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以只显式的指定某些枚举量的值（枚举量的值可以重复）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">colors</span> &#123;red=<span class="number">1</span>,yellow,blue&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将整数强制转换成枚举量，语法：枚举类型(整数)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colors c = (colors)<span class="number">1</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">colors c = yellow; </span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE/" data-id="cmdohx9hl000b30w84rxdfmhx" data-title="枚举" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2025-07-17T10:18:09.966Z" itemprop="datePublished">2025-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构与算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h4 id="单链表结构"><a href="#单链表结构" class="headerlink" title="单链表结构"></a>单链表结构</h4><p>结构体中有一个本结构体的指针，它就是链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> no;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">st_girl</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>     <span class="comment">// 超女单链表。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>      no;               <span class="comment">// 超女编号。</span></span><br><span class="line">	string name;               <span class="comment">// 超女姓名。</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">st_girl</span>* next;      <span class="comment">// 下一个超女节点的地址，如果本节点是最后一条记录，填nullptr。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st_girl *head = <span class="literal">nullptr</span>, *tail = <span class="literal">nullptr</span>, *tmp = <span class="literal">nullptr</span>;    <span class="comment">// head头指针、tail尾指针、tmp临时指针。</span></span><br><span class="line"></span><br><span class="line">	tmp=<span class="keyword">new</span> <span class="built_in">st_girl</span>(&#123; <span class="number">1</span>, <span class="string">&quot;西施&quot;</span>, <span class="literal">nullptr</span> &#125;);      <span class="comment">// 分配第一个节点。</span></span><br><span class="line">	head = tail = tmp;</span><br><span class="line"></span><br><span class="line">	tmp = <span class="keyword">new</span> <span class="built_in">st_girl</span>(&#123; <span class="number">6</span>, <span class="string">&quot;冰冰&quot;</span>, <span class="literal">nullptr</span> &#125;);    <span class="comment">// 分配第二个节点。</span></span><br><span class="line">	tail-&gt;next = tmp;                            <span class="comment">// 把上一个节点的next指针指向新节点。</span></span><br><span class="line">	tail = tmp;                                  <span class="comment">// 移动尾指针，让尾指针指向刚分配出来的新节点。</span></span><br><span class="line"></span><br><span class="line">	tmp = <span class="keyword">new</span> <span class="built_in">st_girl</span>(&#123; <span class="number">3</span>, <span class="string">&quot;幂幂&quot;</span>, <span class="literal">nullptr</span> &#125;);   <span class="comment">// 分配第三个节点。</span></span><br><span class="line">	tail-&gt;next = tmp;                           <span class="comment">// 把上一个节点的next指针指向新节点。</span></span><br><span class="line">	tail = tmp;                                 <span class="comment">// 移动尾指针，让尾指针指向刚分配出来的新节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历单链表"><a href="#遍历单链表" class="headerlink" title="遍历单链表"></a>遍历单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历链表。</span></span><br><span class="line">tmp = head;             <span class="comment">// 从头节点开始。</span></span><br><span class="line"><span class="keyword">while</span> (tmp != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;no=&quot;</span> &lt;&lt; tmp-&gt;no &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; tmp-&gt;name &lt;&lt; <span class="string">&quot;tmp-&gt;next=&quot;</span> &lt;&lt; tmp-&gt;next &lt;&lt; endl;</span><br><span class="line">    tmp = tmp-&gt;next;   <span class="comment">// 顺着next指向往后面找。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放单链表"><a href="#释放单链表" class="headerlink" title="释放单链表"></a>释放单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放链表。</span></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tmp = head;               <span class="comment">// 让临时节点指向头节点。</span></span><br><span class="line">    head = head-&gt;next;  <span class="comment">// 头节点后移。</span></span><br><span class="line">    <span class="keyword">delete</span> tmp;                 <span class="comment">// 删除临时节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cmdohx9hd000830w86pubbymn" data-title="数据结构与算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/结构体" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93/" class="article-date">
  <time class="dt-published" datetime="2025-07-01T12:47:29.655Z" itemprop="datePublished">2025-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基本概念与用法"><a href="#基本概念与用法" class="headerlink" title="基本概念与用法"></a>基本概念与用法</h2><p>结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。<br>使用结构体有两个步骤：</p>
<ul>
<li>定义结构体描述（类型）。</li>
<li>创建结构体变量。</li>
</ul>
<h4 id="定义结构体描述"><a href="#定义结构体描述" class="headerlink" title="定义结构体描述"></a>定义结构体描述</h4><p>struct 结构体名<br>{<br>成员一的数据类型  成员名一;<br>成员二的数据类型  成员名二;<br>成员三的数据类型  成员名三;<br>……<br>成员n的数据类型  成员名n;<br>};</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体名是标识符。</li>
<li>结构体的成员可以是任意数据类型。</li>
<li>定义结构体描述的代码可以放在程序的任何地方，但要考虑定义域，一般放在main函数的上面或头文件中。</li>
<li>结构体成员可以用C++的类（如string），但是不提倡。</li>
<li>在C++中，结构体中可以有函数，但是不提倡。</li>
<li>在C++11中，定义结构体的时候可以指定缺省值。</li>
</ul>
<h4 id="创建结构体变量"><a href="#创建结构体变量" class="headerlink" title="创建结构体变量"></a>创建结构体变量</h4><p><strong>创建结构体变量的语法：</strong><br>struct 结构体名 结构体变量名;<br>在C++中，struct关键字可以不写。<br><strong>也可以为结构体成员赋初始值:</strong><br>struct 结构体名 结构体变量名&#x3D;{成员一的值, 成员二的值,……, 成员n的值};<br>C++11可以不写等于号。<br><strong>如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0。</strong><br>struct 结构体名 结构体变量名&#x3D;{0};<br><strong>可以在定义结构体的时候创建结构体变量。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person1;</span><br><span class="line">Person person2;</span><br><span class="line">Person person3=&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line">Person person4&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体的时候创建结构体变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;person1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;person2&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h4><p>用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。<br>结构体变量名.结构体成员名;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person1;</span><br><span class="line">person<span class="number">1.</span>name=<span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="占用内存的大小"><a href="#占用内存的大小" class="headerlink" title="占用内存的大小"></a>占用内存的大小</h4><p>用sizeof运算符可以得到整个结构体占用内存的大小，且sizeof()对结构体名和结构体变量名的值是一样的。<br>注意：<strong>整个结构体占用内存的大小不一定等于全部成员占用内存之和。</strong><br>内存对齐：#pragma pack(字节数)，修改内存对齐长度，默认是8字节<br>合理使用内存对齐规则，某些节省内存的做法可能毫无意义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person1;</span><br><span class="line"><span class="type">size_t</span> size1 = <span class="built_in">sizeof</span>(person1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(person1) = &quot;</span> &lt;&lt; size1 &lt;&lt; endl;  <span class="comment">// 32</span></span><br><span class="line"><span class="type">size_t</span> size2 = <span class="built_in">sizeof</span>(Person);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(Person) = &quot;</span> &lt;&lt; size2 &lt;&lt; endl;   <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>
<h4 id="清空结构体"><a href="#清空结构体" class="headerlink" title="清空结构体"></a>清空结构体</h4><p>创建的结构体变量如果没有初始化，成员中有垃圾值。<br>用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）<br>bzero()函数也可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void *memset(void *str, int c, size_t n)</span></span><br><span class="line"><span class="comment">将一段内存区域设置为指定的值。</span></span><br><span class="line"><span class="comment">str -- 指向要填充的内存区域的指针。</span></span><br><span class="line"><span class="comment">c -- 要设置的值，通常是一个无符号字符。</span></span><br><span class="line"><span class="comment">n -- 要被设置为该值的字节数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void bzero(void *s, int n);</span></span><br><span class="line"><span class="comment">能够将内存块的前n个字节清零。</span></span><br><span class="line"><span class="comment">s -- 内存指针</span></span><br><span class="line"><span class="comment">n -- 需要清零的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person1;</span><br><span class="line"><span class="built_in">memset</span>(&amp;person1, <span class="number">0</span>, <span class="built_in">sizeof</span>(person1));</span><br><span class="line"><span class="built_in">bzero</span>(&amp;person1, <span class="built_in">sizeof</span>(person1));</span><br></pre></td></tr></table></figure>
<h4 id="复制结构体"><a href="#复制结构体" class="headerlink" title="复制结构体"></a>复制结构体</h4><ul>
<li>用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。</li>
<li>也可以直接用等于号（只适用于C++基本数据类型）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person1;</span><br><span class="line">person<span class="number">1.</span>name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">person<span class="number">1.</span>age=<span class="number">18</span>;</span><br><span class="line">person<span class="number">1.</span>sex=<span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">person<span class="number">1.</span>height=<span class="number">1.7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person2;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;person2, &amp;person1, <span class="built_in">sizeof</span>(person1));</span><br><span class="line">person2=person1;</span><br></pre></td></tr></table></figure>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person1;         <span class="comment">// 声明结构体变量person1。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> *pst = &amp;person1;  <span class="comment">// 声明结构体指针，指向结构体变量person1。</span></span><br></pre></td></tr></table></figure>
<p>通过结构体指针访问结构体成员。</p>
<ul>
<li>(*指针名).成员变量名</li>
<li>指针名-&gt;成员变量名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*pst).name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">pst-&gt;name = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="用于函数的参数"><a href="#用于函数的参数" class="headerlink" title="用于函数的参数"></a>用于函数的参数</h4><p>如果要把结构体传递给函数，由于结构往往整合了许多的成员数据，它的数据量也绝对不可小觑，使用值传递虽然能够保护实参不被修改，但是却会或多或少地影响到程序的运行效率。<br>所以，一般情况使用引用传递，实参取结构体变量的地址，函数的形参用结构体指针。<br>如果不希望在函数中修改结构体变量的值，可以对形参加const约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(Student &amp;stu)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">    student.age = <span class="number">19</span>;</span><br><span class="line">    student.id = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">    student.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printStudent</span>(student);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;student age is &quot;</span> &lt;&lt; student.age &lt;&lt; endl;   <span class="comment">// student age is 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(Student &amp;stu)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;student id is &quot;</span> &lt;&lt; stu.id &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;student name is &quot;</span> &lt;&lt; stu.name &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;student age is &quot;</span> &lt;&lt; stu.age &lt;&lt; endl;   <span class="comment">// student age is 19</span></span><br><span class="line">    stu.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用于动态分配内存"><a href="#用于动态分配内存" class="headerlink" title="用于动态分配内存"></a>用于动态分配内存</h4><p>用结构体指针指向动态分配的内存的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> *pst = <span class="keyword">new</span> Person;</span><br><span class="line"><span class="built_in">memset</span>(pst, <span class="number">0</span>, <span class="built_in">sizeof</span>(Person));     <span class="comment">// 记得初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> *pst = <span class="keyword">new</span> <span class="built_in">Person</span>(&#123;<span class="number">0</span>&#125;);   <span class="comment">// 创建结构体变量并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pst;</span><br></pre></td></tr></table></figure>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。<br><strong>声明结构体数组的语法：</strong><br>struct 结构体类型（结构体名） 数组名[数组长度];<br>在C++中，struct关键字可以不写。<br>初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。<br><strong>使用结构体数组可以用数组表示法，也可以用指针表示法。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person[<span class="number">3</span>];    <span class="comment">// 声明结构体数组变量person，长度为3。</span></span><br><span class="line">person[<span class="number">0</span>]=&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line">person[<span class="number">1</span>]=&#123;<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line">person[<span class="number">2</span>]=&#123;<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line"></span><br><span class="line">*person = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line">*(person + <span class="number">1</span>) = &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line">*(person + <span class="number">2</span>) = &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> person[<span class="number">3</span>]=&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;, &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1.7</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体嵌入数组和结构体"><a href="#结构体嵌入数组和结构体" class="headerlink" title="结构体嵌入数组和结构体"></a>结构体嵌入数组和结构体</h2><h4 id="嵌入数组"><a href="#嵌入数组" class="headerlink" title="嵌入数组"></a>嵌入数组</h4><p>注意区分结构体数组与结构体中的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];        <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span> age;              <span class="comment">// 年龄。</span></span><br><span class="line">    <span class="type">double</span> weight;        <span class="comment">// 体重（kg）。</span></span><br><span class="line">    <span class="type">char</span> sex;             <span class="comment">// 性别：X-女；Y-男。</span></span><br><span class="line">    <span class="type">int</span> mark[<span class="number">3</span>];          <span class="comment">// 三次考试编号。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Human h1 = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">80.5</span>, <span class="string">&#x27;X&#x27;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;;    <span class="comment">//// 创建结构体变量h1，并初始化。</span></span><br><span class="line">Human h[<span class="number">3</span>];     <span class="comment">// 创建结构体数组变量h，长度为3。</span></span><br><span class="line"><span class="comment">// 访问结构体数组成员的mark数组</span></span><br><span class="line">h[<span class="number">0</span>].mark[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 访问结构体变量的mark数组</span></span><br><span class="line">h<span class="number">1.</span>mark[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>嵌入二级数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> mark[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Human* pst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            cout &lt;&lt; pst-&gt;mark[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Human h1;       <span class="comment">// 创建结构体变量h1。</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;h1);      <span class="comment">// 传入结构体变量h1的地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><ul>
<li>无法嵌套自己本身。</li>
<li>嵌套别的结构体变量时，必须在使用之前先定义。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Pet pet;        <span class="comment">// 嵌套结构体变量pet。</span></span><br><span class="line">    Pet pett[<span class="number">3</span>];     <span class="comment">// 嵌套结构体数组pett[3]。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Human h1 = &#123;<span class="string">&quot;char&quot;</span>, <span class="number">18</span>, &#123;<span class="string">&quot;dog&quot;</span>,<span class="number">2</span>&#125;,&#123;&#123;<span class="string">&quot;cat&quot;</span>,<span class="number">3</span>&#125;,&#123;<span class="string">&quot;mouse&quot;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&quot;bird&quot;</span>,<span class="number">5</span>&#125;&#125;&#125;;      <span class="comment">// 创建结构体变量h1，并初始化。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;person1.pett[1].name = &quot;</span> &lt;&lt; person<span class="number">1.</span>pett[<span class="number">1</span>].name  &lt;&lt; <span class="string">&quot; person1.pett[1].age = &quot;</span> &lt;&lt; person<span class="number">1.</span>pett[<span class="number">1</span>].age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体中的指针"><a href="#结构体中的指针" class="headerlink" title="结构体中的指针"></a>结构体中的指针</h2><p>结构体中可以存在指针。<br>如果结构体中的指针指向的是动态分配的内存地址：</p>
<ul>
<li>sizeof 只看“指针变量本身”，不会看“指针指向的动态内存”。</li>
<li>对结构体用memset()函数可能会造成内存泄露。</li>
<li>C++的字符串string(结构体)中有一个指针，指向了动态分配内存的地址。所以在结构体中使用string，要注意上面的情况。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct string</span><br><span class="line">&#123;</span><br><span class="line">	char *ptr;   // 指向动态分配内存的地址。</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_t</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">st_t</span> stt;                   <span class="comment">// 创建结构体变量。</span></span><br><span class="line">    stt.p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];       <span class="comment">// p指向动态分配内存。</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(stt) &lt;&lt; endl;        <span class="comment">// 16B</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(stt.p) &lt;&lt; endl;      <span class="comment">// 8B</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(stt.a) &lt;&lt; endl;      <span class="comment">// 4B,又由于边界对齐，需要补上4B的间隔。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;stt, <span class="number">0</span>, <span class="built_in">sizeof</span>(stt));       <span class="comment">// 会导致将p的值置为0，p成为空指针，原来指向的内存丢失，若不及时释放之前p指向的动态内存，会造成内存泄漏。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若要清空结构体，则逐个清空。</span></span><br><span class="line">    stt.a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(stt.p, <span class="number">0</span>, <span class="number">100</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 清空p指向的动态内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h2><p>共同体（共用体、联合体）是一种特殊的结构体，它能存储不同的数据类型的成员，但是，在同一时间只能存储其中的一个成员的值。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>声明一个 Data 联合体，它可以容纳一个 int、一个 float，或一个 char，但同一时刻只能存储其中一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>所有成员共用同一块内存地址。</li>
<li>占用的空间等于最大成员的大小，同时要注意内存对齐的问题。</li>
<li>在同一时间点，只能有一个成员的数据是有效的。访问其他成员会出现未定义行为。</li>
<li>匿名共同体没有名字，可以在定义的时候创建匿名共同体变量（VS和Linux有差别），也可以嵌入结构体中，并可以通过结构体变量直接访问共同体成员。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">udata</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    udata data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三个成员的地址是相同的。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;data.a的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*)&amp;data.a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;data.b的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*)&amp;data.b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;data.c的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*)&amp;data.c &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 占用的空间等于最大成员的大小，也就是成员c的大小占21字节，但是由于内存对齐，以8字节为单位，所以data占24字节。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(data)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(data) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    data.a = <span class="number">10</span>;    <span class="comment">// 赋值给成员a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; data.a &lt;&lt; endl;      <span class="comment">// 输出成员a的值10</span></span><br><span class="line">    data.b = <span class="number">5.5</span>;   <span class="comment">// 赋值给成员b</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; data.a &lt;&lt; endl;      <span class="comment">// 输出成员a的值是无意义的乱码，因为成员b占用内存，覆盖了成员a的值。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; data.b &lt;&lt; endl;      <span class="comment">// 输出成员b的值5.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//匿名共同体嵌入结构体中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="type">float</span> f;</span><br><span class="line">        &#125;; <span class="comment">// 只有匿名联合体嵌入结构体中，成员才能直接可访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    MyStruct s;</span><br><span class="line">    s.i = <span class="number">42</span>;            <span class="comment">// 可以通过结构体变量直接访问共同体成员 i</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通共同体嵌入结构体中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">        <span class="type">int</span> tag;</span><br><span class="line">        <span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="type">float</span> f;</span><br><span class="line">        &#125; u;  <span class="comment">// 有名字：u</span></span><br><span class="line">    &#125;;</span><br><span class="line">    MyStruct s;</span><br><span class="line">    s.tag = <span class="number">0</span>;</span><br><span class="line">    s.u.i = <span class="number">42</span>;          <span class="comment">// 必须通过 union 的名字访问其成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当一个数据结构中，同一时刻只会使用其中一个变量，可以用 union 减少内存开销。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EventType</span> &#123; MouseEvent, KeyEvent &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mouse</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">    <span class="type">char</span> keycode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    EventType type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Mouse mouse;</span><br><span class="line">        Key key;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(<span class="type">const</span> Event&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.type == MouseEvent) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Mouse at (&quot;</span> &lt;&lt; e.mouse.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; e.mouse.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.type == KeyEvent) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key pressed: &quot;</span> &lt;&lt; e.key.keycode &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于回调函数的参数（相当于支持多种数据类型）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93/" data-id="cmdohx9hn000e30w83ja8a01s" data-title="结构体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/动态分配内存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T11:59:24.196Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/">动态分配内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="使用堆区内存"><a href="#使用堆区内存" class="headerlink" title="使用堆区内存"></a>使用堆区内存</h2><ol>
<li>声明一个指针。</li>
<li>使用 new 运算符向系统申请一块内存，让指针指向这块内存。</li>
<li>通过对指针解引用的方法，像使用变量一样使用这块内存。</li>
<li>如果这块内存不用了，用 delete 运算符释放它。</li>
</ol>
<h2 id="内存申请与释放"><a href="#内存申请与释放" class="headerlink" title="内存申请与释放"></a>内存申请与释放</h2><h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>new 数据类型（初始值）<br>如果申请成功，new 返回的是内存地址，失败则返回 NULL。</p>
<h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><p>delete 地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);    <span class="comment">//申请一个int型大小内存，并初始化为5 </span></span><br><span class="line"><span class="comment">//相当于 int *a = new int;  *a = 3;</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;     <span class="comment">//输出5</span></span><br><span class="line">*p = <span class="number">10</span>;    <span class="comment">//修改内存的值</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;     <span class="comment">//输出10</span></span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。</li>
<li>如果动态分配的内存不用了，必须释放，否则会用尽内存。</li>
<li>动态分配的内存生命周期与程序相同，程序退出时，动态分配的会被系统自动回收。</li>
<li>就算指针的作用域已经失效，所指向的内存也不会释放，一个内存可以由多个指针指向。</li>
<li>用指针跟踪已分配的内存时，不能跟丢。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/" data-id="cmdohx9hb000530w8hhmu6y17" data-title="动态分配内存" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2025-06-25T11:26:26.870Z" itemprop="datePublished">2025-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%87%E9%92%88/">指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h2><p>指针存放变量的地址，指针名表示的是内存地址，指针名前加*（解引用）表示的是内存地址所对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; a &lt;&lt; endl;    <span class="comment">//输出10 10</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; &amp;a &lt;&lt; endl;     <span class="comment">//输出地址值 地址值</span></span><br></pre></td></tr></table></figure>
<h2 id="指针用于函数参数"><a href="#指针用于函数参数" class="headerlink" title="指针用于函数参数"></a>指针用于函数参数</h2><p>如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参（指针）中存放的是实参的地址，在函数中通过解引用指针，就可以访问到实参的值，并且可以修改，这种方式称为地址传递。<br>而值传递，就是把实参的值复制给形参，形参和实参是两个不同的变量，对形参的修改不会影响到实参的值。</p>
<ul>
<li>地址传递的意义<ul>
<li>可以在函数中修改实参的值。</li>
<li>减少内存拷贝，提升性能。</li>
</ul>
</li>
</ul>
<h2 id="用const修饰指针"><a href="#用const修饰指针" class="headerlink" title="用const修饰指针"></a>用const修饰指针</h2><p>见 const与引用和指针.md</p>
<h2 id="函数形参使用-void"><a href="#函数形参使用-void" class="headerlink" title="函数形参使用 void*"></a>函数形参使用 void*</h2><p>表示接受任意数据类型的指针，只关心地址本身，不关心里面的内容。</p>
<ul>
<li>注意事项<ul>
<li>不能对 void* 进行解引用。</li>
<li>把其他类型的指针赋值给 void* 指针不需要转换。</li>
<li>把 void* 指针赋值给其他类型的指针需要转换。</li>
<li>不能用 void 声明变量。</li>
</ul>
</li>
</ul>
<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>二级指针是指针的指针，存放的是指针的地址，指针的地址中存放的是变量的地址。<br>数据类型** 指针名<br>解一次引用是一级指针的值，解二次引用是变量的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> *pii = &amp;ii;</span><br><span class="line"><span class="type">int</span> **ppii = &amp;pii;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ii = &quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;,ii的地址是：&quot;</span> &lt;&lt; &amp;ii &lt;&lt; endl;    <span class="comment">//输出ii = 8 ,ii的地址是：0x7ffc0b7c0c08</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pii = &quot;</span> &lt;&lt; pii &lt;&lt; <span class="string">&quot;,pii的存储地址是：&quot;</span> &lt;&lt; &amp;pii &lt;&lt; <span class="string">&quot;,*pii = &quot;</span>&lt;&lt; *pii &lt;&lt; endl;   <span class="comment">//输出pii = 0x7ffc0b7c0c08 ,pii的存储地址是：0x7ffc0b7c0c0c ，*pii = 8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ppii = &quot;</span> &lt;&lt; ppii &lt;&lt; <span class="string">&quot;,ppii的存储地址是：&quot;</span> &lt;&lt; &amp;ppii &lt;&lt; <span class="string">&quot;,*ppii = &quot;</span>&lt;&lt; *ppii &lt;&lt; <span class="string">&quot;,**ppii = &quot;</span>&lt;&lt; **ppii &lt;&lt; endl;    <span class="comment">//输出ppii = 0x7ffc0b7c0c0c ,ppii的存储地址是：0x7ffc0b7c0c10 ,*ppii = 0x7ffc0b7c0c08 ,**ppii = 8</span></span><br></pre></td></tr></table></figure>
<p>在函数中，如果传递普通变量地址，形参用指针；传递指针的地址，形参用二级指针。<br>目的是把普通变量的地址传入函数后，可以在函数中修改变量的值，把指针的地址传入函数后，可以在函数中修改指针的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数中修改指针的值，却使用一级指针形参，导致修改失败。</span></span><br><span class="line"><span class="comment">// 原因是：传递给一级指针的形参在函数结束时，自动回收，不会影响实参的值。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *pp)</span> </span>&#123;</span><br><span class="line">  pp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;pp = &quot;</span> &lt;&lt; pp &lt;&lt; <span class="string">&quot;,*pp = &quot;</span> &lt;&lt; *pp &lt;&lt; endl;  <span class="comment">//pp = 0x21e99b12530,*pp = 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">func</span>(p);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;,*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//p = 0,*p =</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> **pp)</span> </span>&#123;</span><br><span class="line">  *pp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);   <span class="comment">//*pp实际上是p的值，修改了p的指向。</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;pp = &quot;</span> &lt;&lt; pp &lt;&lt; <span class="string">&quot;,*pp = &quot;</span> &lt;&lt; *pp &lt;&lt; endl;    <span class="comment">//pp = 0xb33ebff918,*pp = 0x2a8bede2530</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">func</span>(&amp;p);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;,*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//p = 0x2a8bede2530,*p = 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要在函数中修改变量的值同理。</span></span><br></pre></td></tr></table></figure>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>给指针赋值为0、NULL或nullptr，表示空指针，没有指向任何地址。</p>
<h4 id="使用空指针的注意事项"><a href="#使用空指针的注意事项" class="headerlink" title="使用空指针的注意事项"></a>使用空指针的注意事项</h4><ul>
<li>空指针不能解引用，如果对空指针解引用，程序会崩溃。</li>
<li>如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。</li>
<li>在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。</li>
</ul>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>野指针就是指针指向的不是一个有效（合法）的地址。在程序中，如果访问野指针，可能会造成程序的崩溃。<br>出现野指针的情况主要有三种：</p>
<ul>
<li>指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。</li>
<li>如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。</li>
<li>指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收），让指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针。</li>
</ul>
<p>规避方法：</p>
<ul>
<li>指针在定义的时候，如果没地方指，就初始化为nullptr。</li>
<li>动态分配的内存被释放后，将其置为nullptr。</li>
<li>函数不要返回局部变量的地址。</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>见 函数.md</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%87%E9%92%88/" data-id="cmdohx9hd000730w8hr022brr" data-title="指针" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/顺序容器库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/20/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2025-04-20T04:43:25.001Z" itemprop="datePublished">2025-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/20/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%BA%93/">顺序容器库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同，对于大多数，但不是所有容器，还需要提供额外的元素类型信息</p>
<table>
<thead>
<tr>
<th align="center">容器</th>
<th align="center">底层结构</th>
<th align="center">是否支持随机访问</th>
<th align="center">插入&#x2F;删除效率</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">std::vector</td>
<td align="center">动态数组</td>
<td align="center">✅</td>
<td align="center">尾部高效，前部&#x2F;中间低效</td>
<td align="center">内存连续、支持下标</td>
</tr>
<tr>
<td align="center">std::deque</td>
<td align="center">双端队列</td>
<td align="center">✅</td>
<td align="center">两端高效</td>
<td align="center">支持两端插入删除</td>
</tr>
<tr>
<td align="center">std::list</td>
<td align="center">双向链表</td>
<td align="center">❌</td>
<td align="center">任意位置高效</td>
<td align="center">不支持随机访问，适合频繁插入删除</td>
</tr>
<tr>
<td align="center">std::forward_list</td>
<td align="center">单向链表（C++11）</td>
<td align="center">❌</td>
<td align="center">插入删除高效</td>
<td align="center">更节省空间，但只支持向前遍历</td>
</tr>
<tr>
<td align="center">std::array</td>
<td align="center">静态数组（C++11）</td>
<td align="center">✅</td>
<td align="center">不支持动态扩容</td>
<td align="center">固定大小，类似 C 数组但更安全</td>
</tr>
</tbody></table>
<h4 id="std-vector（动态数组）"><a href="#std-vector（动态数组）" class="headerlink" title="std::vector（动态数组）"></a>std::vector（动态数组）</h4><p>用于需要快速随机访问和尾部插入删除的场景。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);  <span class="comment">// 尾部插入</span></span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">2</span>];  <span class="comment">// 随机访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-deque（双端队列）"><a href="#std-deque（双端队列）" class="headerlink" title="std::deque（双端队列）"></a>std::deque（双端队列）</h4><p>用于需要快速随机访问和头、尾部插入删除的场景，比 vector 多了头尾端插入的高效性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-list（双向链表）"><a href="#std-list（双向链表）" class="headerlink" title="std::list（双向链表）"></a>std::list（双向链表）</h4><p>常用于频繁在中间插入&#x2F;删除的场景</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>();</span><br><span class="line">    ++it;</span><br><span class="line">    lst.<span class="built_in">insert</span>(it, <span class="number">99</span>);  <span class="comment">// 在第2个元素前插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-forward-list（单向链表）"><a href="#std-forward-list（单向链表）" class="headerlink" title="std::forward_list（单向链表）"></a>std::forward_list（单向链表）</h4><p>常用于频繁在中间插入&#x2F;删除的场景,更轻量，适合低资源环境，缺点是不能逆序或从中间删除前一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; fl = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-array（固定大小数组）"><a href="#std-array（固定大小数组）" class="headerlink" title="std::array（固定大小数组）"></a>std::array（固定大小数组）</h4><p>性能等价于 C 数组，但更安全</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; arr[<span class="number">1</span>];  <span class="comment">// 访问元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h2><h4 id="创建与初始化"><a href="#创建与初始化" class="headerlink" title="创建与初始化"></a>创建与初始化</h4><table>
<thead>
<tr>
<th align="center">构造方式</th>
<th align="center">vector</th>
<th align="center">deque</th>
<th align="center">list</th>
<th align="center">forward_list</th>
<th align="center">array</th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认构造</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅（但不清零）</td>
</tr>
<tr>
<td align="center">指定大小</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">指定大小+值</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌（用 fill）</td>
</tr>
<tr>
<td align="center">初始化列表</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">拷贝构造</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">迭代器构造</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">移动构造（C++11）</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<h5 id="std-vector-的构造函数示例"><a href="#std-vector-的构造函数示例" class="headerlink" title="std::vector 的构造函数示例"></a>std::vector 的构造函数示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 默认构造：空容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 指定大小：默认值初始化（int 默认为0）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 指定大小+初始值</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">42</span>)</span></span>;  <span class="comment">// [42, 42, 42, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 初始化列表</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 拷贝构造</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 迭代器构造（拷贝部分）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v6</span><span class="params">(v<span class="number">4.</span>begin(), v<span class="number">4.</span>begin() + <span class="number">2</span>)</span></span>;  <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 移动构造（C++11）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v7</span><span class="params">(std::move(v5))</span></span>;  <span class="comment">// v5 清空</span></span><br></pre></td></tr></table></figure>
<h5 id="std-deque-的构造函数示例"><a href="#std-deque-的构造函数示例" class="headerlink" title="std::deque 的构造函数示例"></a>std::deque 的构造函数示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; d1;                       <span class="comment">// 默认构造</span></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">3</span>)</span></span>;                    <span class="comment">// [0, 0, 0]</span></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">3</span>, <span class="number">7</span>)</span></span>;                 <span class="comment">// [7, 7, 7]</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; d4 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d5</span><span class="params">(d4)</span></span>;                   <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d6</span><span class="params">(d<span class="number">4.</span>begin(), d<span class="number">4.</span>end())</span></span>; <span class="comment">// 迭代器构造</span></span><br></pre></td></tr></table></figure>
<h5 id="std-list-的构造函数示例"><a href="#std-list-的构造函数示例" class="headerlink" title="std::list 的构造函数示例"></a>std::list 的构造函数示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l1;                        <span class="comment">// 空 list</span></span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(<span class="number">4</span>)</span></span>;                     <span class="comment">// [0, 0, 0, 0]</span></span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(<span class="number">4</span>, <span class="number">9</span>)</span></span>;                  <span class="comment">// [9, 9, 9, 9]</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l4 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;            <span class="comment">// 初始化列表</span></span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l5</span><span class="params">(l4)</span></span>;                    <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l6</span><span class="params">(l<span class="number">4.</span>begin(), l<span class="number">4.</span>end())</span></span>;  <span class="comment">// 迭代器构造</span></span><br></pre></td></tr></table></figure>
<h5 id="std-forward-list-构造函数示例"><a href="#std-forward-list-构造函数示例" class="headerlink" title="std::forward_list 构造函数示例"></a>std::forward_list 构造函数示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; fl1;                      <span class="comment">// 空</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">fl2</span><span class="params">(<span class="number">3</span>)</span></span>;                   <span class="comment">// [0, 0, 0]</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">fl3</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>)</span></span>;                <span class="comment">// [1, 1, 1]</span></span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; fl4 = &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;         <span class="comment">// 初始化列表</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">fl5</span><span class="params">(fl4)</span></span>;                 <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">fl6</span><span class="params">(fl<span class="number">4.</span>begin(), fl<span class="number">4.</span>end())</span></span>;  <span class="comment">// 迭代器构造</span></span><br></pre></td></tr></table></figure>
<h5 id="std-array-的创建与初始化"><a href="#std-array-的创建与初始化" class="headerlink" title="std::array 的创建与初始化"></a>std::array 的创建与初始化</h5><ul>
<li>必须指定元素类型，和容器大小；</li>
<li>std::array 大小必须是编译期常量；</li>
<li>不支持动态大小构造；</li>
<li>不支持传入大小或初始值的构造函数；</li>
<li>可用 .fill() 赋相同值：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a1;             <span class="comment">// 默认构造（值未定义）</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 初始化列表</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a3&#123;&#125;;           <span class="comment">// 所有元素设为0</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a4 = &#123;&#125;;        <span class="comment">// 同上，初始化为0</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a5 = a2;        <span class="comment">// 拷贝构造</span></span><br><span class="line"></span><br><span class="line">a<span class="number">1.f</span>ill(<span class="number">42</span>);  <span class="comment">// 全部设为 42</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h4><table>
<thead>
<tr>
<th align="center">操作方式</th>
<th align="center">vector</th>
<th align="center">deque</th>
<th align="center">list</th>
<th align="center">forward_list</th>
<th align="center">array</th>
</tr>
</thead>
<tbody><tr>
<td align="center">拷贝赋值 &#x3D;</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">初始化列表 &#x3D;</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">assign(n, val)</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">assign(iter1,iter2)</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">迭代器要求是InputIterator</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">swap() 成员函数</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅（逐元素）</td>
</tr>
<tr>
<td align="center">std::swap</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<ul>
<li>所有标准顺序容器（如 vector, deque, list, forward_list, array）都支持 拷贝赋值，除了std::array 外可以用花括号直接赋值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2 = v1;  <span class="comment">// 拷贝 v1 的所有元素</span></span><br><span class="line">v2 = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  <span class="comment">// 使用 initializer_list 重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::array 可以用列表初始化，但不能用花括号直接赋值。</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">a = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;   <span class="comment">// ❌ 错误！不能用大括号直接赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>区间赋值（通过 assign(iter1,iter2)）  </li>
<li>n 个相同值赋值（assign(n, val)）</li>
<li>清除当前容器中的所有元素，并用初始化列表中的元素替换(assign(il))<br>由于assign() 支持的容器：vector, deque, list, forward_list<br>std::array 没有 assign()，只能通过索引或 fill()。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">v<span class="number">3.</span><span class="built_in">assign</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());  <span class="comment">// 拷贝范围</span></span><br><span class="line">v<span class="number">3.</span><span class="built_in">assign</span>(<span class="number">4</span>, <span class="number">100</span>);  <span class="comment">// v3 变成 [100, 100, 100, 100]</span></span><br><span class="line">v<span class="number">3.</span><span class="built_in">assign</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;);    <span class="comment">//v3 又变成[10, 20, 30, 40]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//forward_list::assign() 的迭代器要求：InputIterator</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line"><span class="comment">// 错误：list 的 reverse_iterator 是 BidirectionalIterator，不兼容 forward_list 的 assign</span></span><br><span class="line">fl.<span class="built_in">assign</span>(lst.<span class="built_in">rbegin</span>(), lst.<span class="built_in">rend</span>()); <span class="comment">// ❌ 编译错误</span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; a1;</span><br><span class="line">a<span class="number">1.f</span>ill(<span class="number">100</span>);   <span class="comment">// 全部设为 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>所有标准顺序容器（如 vector, deque, list, forward_list, array）都支持swap()<br>swap操作交换俩个相同类型容器的内容，调用swap之后，俩个容器的元素将会交换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">swap</span>(v2);  <span class="comment">// 交换两容器的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用 全局函数 std::swap</span></span><br><span class="line">std::<span class="built_in">swap</span>(v1, v2);  <span class="comment">// 效果和 v1.swap(v2) 相同</span></span><br></pre></td></tr></table></figure>
<h5 id="不同容器下的swap"><a href="#不同容器下的swap" class="headerlink" title="不同容器下的swap"></a>不同容器下的swap</h5><ul>
<li>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成</li>
<li>除array string外，指向容器的迭代器、引用和指针在swap操作之后不会失效，仍然指向swap操作之前的那些元素，也就是指向了交换后的新容器中的元素</li>
<li>对于string，调用swap会导致迭代器、引用和指针失效。</li>
<li>对于array，swap会真正交换俩个容器的元素，因此交换时间与元素数量成正比。在swap操作后，迭代器、引用和指针绑定的元素不变，但值被交换了，指向的还是原来的容器中的元素。</li>
</ul>
<h4 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h4><table>
<thead>
<tr>
<th align="center">操作函数</th>
<th align="center">vector</th>
<th align="center">deque</th>
<th align="center">list</th>
<th align="center">forward_list</th>
<th align="center">array</th>
</tr>
</thead>
<tbody><tr>
<td align="center">size()</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌（需手动）</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">resize()</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">max_size()</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">capacity()</td>
<td align="center">✅</td>
<td align="center">（非标准可能有）</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">shrink_to_fit()</td>
<td align="center">✅</td>
<td align="center">（部分支持）</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<h5 id="vector-大小操作示例"><a href="#vector-大小操作示例" class="headerlink" title="vector 大小操作示例"></a>vector 大小操作示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;          <span class="comment">// 当前元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 当前分配的空间</span></span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">5</span>);  <span class="comment">// 扩展为5个元素，新增元素为0</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">2</span>);  <span class="comment">// 缩小为2个元素</span></span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">shrink_to_fit</span>(); <span class="comment">// 请求收缩 capacity（不一定生效）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty: &quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; endl;        <span class="comment">// 是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="deque-大小操作示例"><a href="#deque-大小操作示例" class="headerlink" title="deque 大小操作示例"></a>deque 大小操作示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty: &quot;</span> &lt;&lt; d.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">99</span>);  <span class="comment">// 扩展，补99</span></span><br><span class="line">    d.<span class="built_in">resize</span>(<span class="number">1</span>);      <span class="comment">// 缩小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：deque 通常没有 capacity()，但某些实现可能提供（非标准）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="list-大小操作示例"><a href="#list-大小操作示例" class="headerlink" title="list 大小操作示例"></a>list 大小操作示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty: &quot;</span> &lt;&lt; l.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">resize</span>(<span class="number">5</span>, <span class="number">-1</span>);  <span class="comment">// 加元素 -1</span></span><br><span class="line">    l.<span class="built_in">resize</span>(<span class="number">2</span>);      <span class="comment">// 去掉尾部元素</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_size: &quot;</span> &lt;&lt; l.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="forward-list-大小操作示例（⚠️-不支持-size-）"><a href="#forward-list-大小操作示例（⚠️-不支持-size-）" class="headerlink" title="forward_list 大小操作示例（⚠️ 不支持 size()）"></a>forward_list 大小操作示例（⚠️ 不支持 size()）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; fl = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️ forward_list 没有 size()</span></span><br><span class="line">    <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : fl) ++count;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;manual size: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty: &quot;</span> &lt;&lt; fl.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    fl.<span class="built_in">resize</span>(<span class="number">5</span>, <span class="number">99</span>);  <span class="comment">// 扩展</span></span><br><span class="line">    fl.<span class="built_in">resize</span>(<span class="number">2</span>);      <span class="comment">// 缩小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="array-大小操作示例（固定大小）"><a href="#array-大小操作示例（固定大小）" class="headerlink" title="array 大小操作示例（固定大小）"></a>array 大小操作示例（固定大小）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; endl;      <span class="comment">// 固定为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_size: &quot;</span> &lt;&lt; arr.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty: &quot;</span> &lt;&lt; arr.<span class="built_in">empty</span>() &lt;&lt; endl;    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️ array 没有 resize()，无法增减元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>虽然容器都支持 &#x3D;&#x3D; !&#x3D; &lt; &gt; &lt;&#x3D; &gt;&#x3D;关系运算符，但若元素类型不支持 &lt; 等操作，则容器也无法使用这些运算符（比如自定义类没重载 &lt;）。<br>关系运算符左右俩边的对象必须是相同类型的容器。<br>比较俩个容器实际上是进行元素的逐对比较。</p>
<ul>
<li>如果俩个容器具有相同大小且所有元素都俩俩对应相等，则这俩个容器相等，否则不等。</li>
<li>如果俩个容器大小不同，但较小容器中每个元素都等于较大容器中对应元素，则较大容器大</li>
<li>如果俩个容器都不是前缀子序列，则比较第一个元素，大则容器大</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li>iterator：双向迭代器（list, deque, vector）和随机访问迭代器（vector、deque）。</li>
<li>const_iterator：只读迭代器，用于访问元素而不允许修改。</li>
<li>reverse_iterator：反向迭代器，允许从容器末尾向前遍历。（不支持forward_list）</li>
<li>const_reverse_iterator:不能修改元素的逆序迭代器。 （不支持forward_list）</li>
<li>emplace_iterator：用于支持原地构造的容器，如 list, deque 等。</li>
</ul>
<h5 id="合法的迭代器范围规则："><a href="#合法的迭代器范围规则：" class="headerlink" title="合法的迭代器范围规则："></a>合法的迭代器范围规则：</h5><p>如果begin与end相等，则范围为空<br>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素<br>我们可以队begin递增若干次，使得begin&#x3D;&#x3D;end</p>
<h5 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">begin</span>()      <span class="comment">// 指向第一个元素</span></span><br><span class="line">v.<span class="built_in">end</span>()        <span class="comment">// 指向最后一个元素之后的位置</span></span><br><span class="line">v.<span class="built_in">rbegin</span>()     <span class="comment">// 指向最后一个元素（反向）</span></span><br><span class="line">v.<span class="built_in">rend</span>()       <span class="comment">// 指向第一个元素之前的位置（反向）</span></span><br><span class="line">v.<span class="built_in">cbegin</span>()     <span class="comment">// 返回一个 const_iterator，指向容器的第一个元素。</span></span><br><span class="line">v.<span class="built_in">cend</span>()       <span class="comment">// 返回一个 const_iterator，指向最后一个元素之后的位置</span></span><br><span class="line">v.<span class="built_in">crbegin</span>()    <span class="comment">// 返回一个 const_reverse_iterator，指向最后一个元素的位置</span></span><br><span class="line">v.<span class="built_in">crend</span>()      <span class="comment">// 返回一个 const_reverse_iterator，指向第一个元素前一个位置</span></span><br></pre></td></tr></table></figure>
<h5 id="auto与迭代器"><a href="#auto与迭代器" class="headerlink" title="auto与迭代器"></a>auto与迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c.begin() 的返回类型是 iterator 还是 const_iterator，取决于 c 是否是 const 对象。</span></span><br><span class="line"><span class="keyword">auto</span> it = c.<span class="built_in">begin</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = c.<span class="built_in">cbegin</span>()	<span class="comment">// const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it = c.<span class="built_in">rbegin</span>()	<span class="comment">// reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it = c.<span class="built_in">crbegin</span>()   <span class="comment">// const_reverse_iterator</span></span><br></pre></td></tr></table></figure>
<h4 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h4><table>
<thead>
<tr>
<th align="center">容器</th>
<th align="center">push_back</th>
<th align="center">push_front</th>
<th align="center">insert</th>
<th align="center">erase</th>
<th align="center">pop_back</th>
<th align="center">pop_front</th>
<th align="center">remove</th>
<th align="center">emplace_*</th>
<th align="center">clear</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vector</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">deque</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">list</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">forward_list</td>
<td align="center">❌(支持前插)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">erase_after</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅（after）</td>
<td align="center">✅（C++20）</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<h5 id="vector-添加与删除元素"><a href="#vector-添加与删除元素" class="headerlink" title="vector 添加与删除元素"></a>vector 添加与删除元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);            <span class="comment">// 尾部添加</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">20</span>);         <span class="comment">// 原地构造添加（效率更高效果一样）</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">5</span>);     <span class="comment">// 指定位置插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    v.<span class="built_in">pop_back</span>();               <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());         <span class="comment">// 删除指定位置元素</span></span><br><span class="line">    v.<span class="built_in">clear</span>();                  <span class="comment">// 清空所有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="deque-添加与删除元素（支持前后双端操作）"><a href="#deque-添加与删除元素（支持前后双端操作）" class="headerlink" title="deque 添加与删除元素（支持前后双端操作）"></a>deque 添加与删除元素（支持前后双端操作）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);             <span class="comment">// 尾部添加</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>);            <span class="comment">// 头部添加</span></span><br><span class="line">    d.<span class="built_in">emplace_back</span>(<span class="number">2</span>);          <span class="comment">// 尾部原地构造</span></span><br><span class="line">    d.<span class="built_in">emplace_front</span>(<span class="number">-1</span>);        <span class="comment">// 头部原地构造</span></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">99</span>);<span class="comment">// 插入到第二个位置</span></span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">pop_back</span>();               <span class="comment">// 删除尾部</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();              <span class="comment">// 删除头部</span></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());         <span class="comment">// 删除第一个元素</span></span><br><span class="line">    d.<span class="built_in">clear</span>();                  <span class="comment">// 清空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="list-添加与删除元素（支持前后双端-任意位置插入）"><a href="#list-添加与删除元素（支持前后双端-任意位置插入）" class="headerlink" title="list 添加与删除元素（支持前后双端 + 任意位置插入）"></a>list 添加与删除元素（支持前后双端 + 任意位置插入）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">10</span>);              <span class="comment">// 尾部</span></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">5</span>);              <span class="comment">// 头部</span></span><br><span class="line">    l.<span class="built_in">emplace_back</span>(<span class="number">15</span>);</span><br><span class="line">    l.<span class="built_in">emplace_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = l.<span class="built_in">begin</span>();</span><br><span class="line">    ++it;</span><br><span class="line">    l.<span class="built_in">insert</span>(it, <span class="number">7</span>);              <span class="comment">// 插入在第二个位置</span></span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">pop_back</span>();                 <span class="comment">// 删除最后一个</span></span><br><span class="line">    l.<span class="built_in">pop_front</span>();                <span class="comment">// 删除第一个</span></span><br><span class="line">    l.<span class="built_in">erase</span>(l.<span class="built_in">begin</span>());           <span class="comment">// 删除第一个</span></span><br><span class="line">    l.<span class="built_in">remove</span>(<span class="number">7</span>);                  <span class="comment">// 删除值为7的所有元素</span></span><br><span class="line">    l.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="forward-list-添加与删除元素（只能在前或指定前一个节点后插入）"><a href="#forward-list-添加与删除元素（只能在前或指定前一个节点后插入）" class="headerlink" title="forward_list 添加与删除元素（只能在前或指定前一个节点后插入）"></a>forward_list 添加与删除元素（只能在前或指定前一个节点后插入）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; fl = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">0</span>);                      <span class="comment">// 添加到头部</span></span><br><span class="line">    fl.<span class="built_in">emplace_front</span>(<span class="number">-1</span>);                  <span class="comment">// 原地构造添加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = fl.<span class="built_in">before_begin</span>();</span><br><span class="line">    fl.<span class="built_in">insert_after</span>(it, <span class="number">100</span>);              <span class="comment">// 插入到头前（即第一个元素前）</span></span><br><span class="line">    fl.<span class="built_in">emplace_after</span>(it, <span class="number">200</span>);             <span class="comment">// 原地构造插入(效果等同)</span></span><br><span class="line"></span><br><span class="line">    fl.<span class="built_in">pop_front</span>();                        <span class="comment">// 删除头部元素</span></span><br><span class="line">    fl.<span class="built_in">erase_after</span>(fl.<span class="built_in">before_begin</span>());     <span class="comment">// 删除第一个元素</span></span><br><span class="line">    fl.<span class="built_in">remove</span>(<span class="number">2</span>);                          <span class="comment">// 删除所有值为2的元素</span></span><br><span class="line">    fl.<span class="built_in">clear</span>();                            <span class="comment">// C++20 起支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="array-无法添加删除元素（固定大小）"><a href="#array-无法添加删除元素（固定大小）" class="headerlink" title="array 无法添加删除元素（固定大小）"></a>array 无法添加删除元素（固定大小）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ❌ 没有 push_back、pop_back、insert、erase</span></span><br><span class="line">    <span class="comment">// ✅ 你可以手动修改元素，但不能改变数组大小</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-remove-if-删除符合条件的元素"><a href="#使用-remove-if-删除符合条件的元素" class="headerlink" title="使用 remove_if 删除符合条件的元素"></a>使用 remove_if 删除符合条件的元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有偶数</span></span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v 变为：1, 3, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/20/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%BA%93/" data-id="cmdohx9hn000d30w8er0q8kyk" data-title="顺序容器库" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/IO库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2025-04-18T11:28:47.556Z" itemprop="datePublished">2025-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO%E5%BA%93/">IO库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="核心基类体系"><a href="#核心基类体系" class="headerlink" title="核心基类体系"></a>核心基类体系</h2><p>C++ 的输入输出流系统是基于继承体系构建的，主要的几个核心类包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   ios_base</span><br><span class="line">       ↑</span><br><span class="line">      ios</span><br><span class="line">     ↙   ↘</span><br><span class="line">istream  ostream</span><br><span class="line">     ↘   ↙</span><br><span class="line">    iostream</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios_base</td>
<td align="center">基类</td>
<td align="center">所有流类的最终基类，提供状态、格式标志等</td>
</tr>
<tr>
<td align="center">ios</td>
<td align="center">模板基类</td>
<td align="center">ios_base 的子类，支持数据类型管理</td>
</tr>
<tr>
<td align="center">istream</td>
<td align="center">输入流类</td>
<td align="center">继承 ios，定义提取运算符 &gt;&gt;、get() 等</td>
</tr>
<tr>
<td align="center">ostream</td>
<td align="center">输出流类</td>
<td align="center">继承 ios，定义插入运算符 &lt;&lt;、put() 等</td>
</tr>
<tr>
<td align="center">iostream</td>
<td align="center">输入输出流类</td>
<td align="center">继承自 istream 和 ostream，支持读写</td>
</tr>
</tbody></table>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p>定义在头文件 <iostream> 中，默认使用的是 std 命名空间。包含istream，ostream以及iostream类型，根据这些类型创建对象完成输入输出的操作。</p>
<ul>
<li>std::istream - 输入流类型<ul>
<li>功能：用于从输入设备读取数据（例如键盘、文件）。</li>
<li>常用对象：<ul>
<li>std::cin：标准输入流，通常从键盘读取数据。</li>
</ul>
</li>
</ul>
</li>
<li>std::ostream - 输出流类型<ul>
<li>功能：用于向输出设备（通常是屏幕）写入数据。</li>
<li>常用对象：<ul>
<li>std::cout：标准输出流，通常向屏幕输出数据。</li>
<li>std::cerr：标准错误流，通常用于输出错误信息。</li>
<li>std::clog：标准日志流，通常用于输出日志信息。</li>
</ul>
</li>
</ul>
</li>
<li>std::iostream — 输入输出流类型<ul>
<li>功能：用于支持同时输入和输出。</li>
<li>是 istream 和 ostream 的组合类。</li>
<li>虽然标准流（如 cin, cout）本身是 istream 或 ostream 类型，但一些流（如 fstream) 就继承自 iostream。</li>
</ul>
</li>
</ul>
<h4 id="常用的输入函数"><a href="#常用的输入函数" class="headerlink" title="常用的输入函数"></a>常用的输入函数</h4><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cin &gt;&gt; var</td>
<td align="center">读取基本数据类型，跳过空白（空格、制表符、换行符）</td>
</tr>
<tr>
<td align="center">getline(cin, s)</td>
<td align="center">读取整行（包括空格）</td>
</tr>
<tr>
<td align="center">cin.get(ch)</td>
<td align="center">读取一个字符（包括空格）</td>
</tr>
<tr>
<td align="center">cin.read(buf, n)</td>
<td align="center">读取 n 个字节，常用于二进制</td>
</tr>
</tbody></table>
<h4 id="错误输出流-cerr-和-clog"><a href="#错误输出流-cerr-和-clog" class="headerlink" title="错误输出流 cerr 和 clog"></a>错误输出流 cerr 和 clog</h4><p>cerr 不带缓冲，即时输出，适合输出错误信息。<br>clog 带缓冲，用于日志记录。</p>
<h4 id="输入状态检查与处理"><a href="#输入状态检查与处理" class="headerlink" title="输入状态检查与处理"></a>输入状态检查与处理</h4><p>C++ 流输入经常会出错，需要检查状态。</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cin.good()</td>
<td align="center">一切正常，则返回true</td>
</tr>
<tr>
<td align="center">cin.fail()</td>
<td align="center">出现非致命错误，比如类型不匹配，则返回true</td>
</tr>
<tr>
<td align="center">cin.bad()</td>
<td align="center">出现严重错误，比如硬件问题，则返回true</td>
</tr>
<tr>
<td align="center">cin.eof()</td>
<td align="center">到达输入末尾（EOF），则返回true</td>
</tr>
<tr>
<td align="center">cin.clear()</td>
<td align="center">清除错误状态，返回void</td>
</tr>
</tbody></table>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>头文件 <fstream> 提供了用于文件读写的三个主要类：</p>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">功能</th>
<th align="center">继承自</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifstream</td>
<td align="center">输入文件流（读取文件）</td>
<td align="center">istream</td>
</tr>
<tr>
<td align="center">ofstream</td>
<td align="center">输出文件流（写入文件）</td>
<td align="center">ostream</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="center">输入输出文件流</td>
<td align="center">iostream</td>
</tr>
</tbody></table>
<h4 id="文件流常用成员函数"><a href="#文件流常用成员函数" class="headerlink" title="文件流常用成员函数"></a>文件流常用成员函数</h4><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">功能说明</th>
<th align="center">示例用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">open()</td>
<td align="center">打开一个文件</td>
<td align="center">file.open(“data.txt”, ios::in);</td>
</tr>
<tr>
<td align="center">is_open()</td>
<td align="center">判断文件是否成功打开</td>
<td align="center">if (file.is_open())</td>
</tr>
<tr>
<td align="center">close()</td>
<td align="center">关闭文件（释放资源）</td>
<td align="center">file.close();</td>
</tr>
<tr>
<td align="center">eof()</td>
<td align="center">判断是否到达文件末尾</td>
<td align="center">while (!file.eof())</td>
</tr>
<tr>
<td align="center">fail()</td>
<td align="center">判断是否读取失败或格式错误</td>
<td align="center">if (file.fail())</td>
</tr>
<tr>
<td align="center">good()</td>
<td align="center">判断是否一切正常（没错）</td>
<td align="center">if (file.good())</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">清除错误标志，恢复流状态</td>
<td align="center">file.clear();</td>
</tr>
<tr>
<td align="center">seekg()</td>
<td align="center">设置输入流的位置（get）</td>
<td align="center">file.seekg(0);</td>
</tr>
<tr>
<td align="center">seekp()</td>
<td align="center">设置输出流的位置（put）</td>
<td align="center">file.seekp(0, ios::end);</td>
</tr>
<tr>
<td align="center">tellg()</td>
<td align="center">返回当前输入位置（get pointer）</td>
<td align="center">int pos &#x3D; file.tellg();</td>
</tr>
<tr>
<td align="center">tellp()</td>
<td align="center">返回当前输出位置（put pointer）</td>
<td align="center">int pos &#x3D; file.tellp();</td>
</tr>
<tr>
<td align="center">getline()</td>
<td align="center">从文件读取一整行</td>
<td align="center">getline(file, str);</td>
</tr>
<tr>
<td align="center">read()</td>
<td align="center">从文件中读入二进制数据（低层）</td>
<td align="center">file.read(buf, size);</td>
</tr>
<tr>
<td align="center">write()</td>
<td align="center">向文件写入二进制数据（低层）</td>
<td align="center">file.write(buf, size);</td>
</tr>
</tbody></table>
<h5 id="open-is-open"><a href="#open-is-open" class="headerlink" title="open() &#x2F; is_open()"></a>open() &#x2F; is_open()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fstream file;</span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in | ios::out);</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件成功打开&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">close</span>();  <span class="comment">// 关闭并保存修改，释放资源</span></span><br></pre></td></tr></table></figure>
<h5 id="eof-（是否到达文件末尾）"><a href="#eof-（是否到达文件末尾）" class="headerlink" title="eof()（是否到达文件末尾）"></a>eof()（是否到达文件末尾）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (!file.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    <span class="built_in">getline</span>(file, line);</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fail-good-clear"><a href="#fail-good-clear" class="headerlink" title="fail() &#x2F; good() &#x2F; clear()"></a>fail() &#x2F; good() &#x2F; clear()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file &gt;&gt; num;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取失败，格式不对！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    file.<span class="built_in">clear</span>(); <span class="comment">// 重置流状态</span></span><br><span class="line">    file.<span class="built_in">ignore</span>(<span class="number">1000</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 清除错误输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="seekg-seekp-（移动文件指针）"><a href="#seekg-seekp-（移动文件指针）" class="headerlink" title="seekg() &#x2F; seekp()（移动文件指针）"></a>seekg() &#x2F; seekp()（移动文件指针）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 读指针移到文件开头</span></span><br><span class="line">file.<span class="built_in">seekp</span>(<span class="number">0</span>, ios::end); <span class="comment">// 写指针移到文件末尾</span></span><br></pre></td></tr></table></figure>
<h5 id="tellg-tellp-（获取当前指针位置）"><a href="#tellg-tellp-（获取当前指针位置）" class="headerlink" title="tellg() &#x2F; tellp()（获取当前指针位置）"></a>tellg() &#x2F; tellp()（获取当前指针位置）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = file.<span class="built_in">tellg</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前位置：&quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h5 id="read-write-（二进制文件处理）"><a href="#read-write-（二进制文件处理）" class="headerlink" title="read() &#x2F; write()（二进制文件处理）"></a>read() &#x2F; write()（二进制文件处理）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">file.<span class="built_in">read</span>(buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 读取二进制内容</span></span><br><span class="line">file.<span class="built_in">write</span>(buffer, <span class="built_in">sizeof</span>(buffer)); <span class="comment">// 写入二进制内容</span></span><br></pre></td></tr></table></figure>
<h4 id="打开文件的方式（open-的第二个参数）"><a href="#打开文件的方式（open-的第二个参数）" class="headerlink" title="打开文件的方式（open 的第二个参数）"></a>打开文件的方式（open 的第二个参数）</h4><p>用 fstream、ifstream、ofstream 打开文件时传入的第二个参数，控制文件是以读、写、追加、二进制等方式打开的。使用的是 ios 枚举值，组合使用可以用 |。</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::in</td>
<td align="center">输入（读取）模式</td>
</tr>
<tr>
<td align="center">ios::out</td>
<td align="center">输出（写入）模式</td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">追加到文件末尾</td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">打开时清空原内容（ios::out 的默认行为）</td>
</tr>
<tr>
<td align="center">ios::binary</td>
<td align="center">二进制模式</td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">打开文件并定位到文件末尾</td>
</tr>
</tbody></table>
<ul>
<li><p>只可以对ofstream或fstream对象设定out模式</p>
</li>
<li><p>只可以对ifstream或fstream对象设定in模式</p>
</li>
<li><p>只有当out也被设定时才可设定trunc模式</p>
</li>
<li><p>只要trunc没被设定，就可以设定app模式，在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>, ios::app)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>, ios::app | ios::out)</span></span>;  <span class="comment">// 等价</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断，为保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//实际等价于</span></span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc)</span></span>;       <span class="comment">//这会 清空已有内容，然后从头开始写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式</span></span><br><span class="line"><span class="comment">//1. 追加写入：加上 ios::app 模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::app)</span></span>;     <span class="comment">//这样打开文件时不会清空，而是在文件末尾追加内容。</span></span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::app)</span></span>; <span class="comment">// 等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 同时读写文件，不清空内容：加上 ios::in</span></span><br><span class="line"><span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::in | ios::out)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。</p>
</li>
<li><p>ios::app 是强制只能在末尾追加（写操作只能在末尾）而ios::ate 是“打开时”跳到末尾，但之后可以跳到任意位置写入或读取！</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::in | ios::out | ios::ate)</span></span>;</span><br><span class="line">file &lt;&lt; <span class="string">&quot;追加的内容&quot;</span>;       <span class="comment">// 写在末尾</span></span><br><span class="line">file.<span class="built_in">seekp</span>(<span class="number">0</span>);             </span><br><span class="line">file &lt;&lt; <span class="string">&quot;覆盖前面的内容&quot;</span>;   <span class="comment">// 可以跳转位置修改</span></span><br></pre></td></tr></table></figure>

<h4 id="常见打开文件的方式"><a href="#常见打开文件的方式" class="headerlink" title="常见打开文件的方式"></a>常见打开文件的方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream file;</span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;  <span class="comment">//这个构造函数自动在创建对象的同时就调用了 open() 方法，并且以默认的 ios::in（输入模式） 打开文件。</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">默认模式</th>
<th align="center">构造函数行为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifstream</td>
<td align="center">ios::in</td>
<td align="center">打开文件用于读取</td>
</tr>
<tr>
<td align="center">ofstream</td>
<td align="center">ios::out</td>
<td align="center">打开文件用于写入（默认会清空内容）</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="center">ios::in ios::out</td>
<td align="center">同时读写</td>
</tr>
</tbody></table>
<h5 id="1-创建并打开当前目录下的文件："><a href="#1-创建并打开当前目录下的文件：" class="headerlink" title="1. 创建并打开当前目录下的文件："></a>1. 创建并打开当前目录下的文件：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;  <span class="comment">// data.txt 在当前目录</span></span><br></pre></td></tr></table></figure>
<h5 id="2-创建并打开绝对路径下的文件（Windows-示例）："><a href="#2-创建并打开绝对路径下的文件（Windows-示例）：" class="headerlink" title="2. 创建并打开绝对路径下的文件（Windows 示例）："></a>2. 创建并打开绝对路径下的文件（Windows 示例）：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;C:\\Users\\YourName\\Documents\\myfile.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-使用-fstream-同时读写："><a href="#3-使用-fstream-同时读写：" class="headerlink" title="3. 使用 fstream 同时读写："></a>3. 使用 fstream 同时读写：</h5><p>使用 fstream 时，要手动指定读&#x2F;写模式（ios::in | ios::out）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;C:\\path\\to\\file.txt&quot;</span>, ios::in | ios::out)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="写入文件-ofstream"><a href="#写入文件-ofstream" class="headerlink" title="写入文件 (ofstream)"></a>写入文件 (ofstream)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;  <span class="comment">// 默认 ios::out</span></span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Hello, 文件流！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;第二行内容&quot;</span> &lt;&lt; endl;</span><br><span class="line">    outFile.<span class="built_in">close</span>();  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="读取文件-ifstream"><a href="#读取文件-ifstream" class="headerlink" title="读取文件 (ifstream)"></a>读取文件 (ifstream)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;  <span class="comment">// 默认 ios::in</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法打开文件进行读取。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(inFile, line)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;读取内容：&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同时读写-fstream"><a href="#同时读写-fstream" class="headerlink" title="同时读写 (fstream)"></a>同时读写 (fstream)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, ios::in | ios::out | ios::trunc)</span></span>;  <span class="comment">// 同时读写并清空文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file &lt;&lt; <span class="string">&quot;写入一些数据。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>);  <span class="comment">// 读前要将文件位置移动到开头</span></span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(file, line);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取到的数据：&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>#include <sstream>  头文件 提供 stringstream、istringstream、ostringstream 三种类型</p>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">用途</th>
<th align="center">继承自</th>
</tr>
</thead>
<tbody><tr>
<td align="center">istringstream</td>
<td align="center">从字符串中读取数据（输入流）</td>
<td align="center">istream</td>
</tr>
<tr>
<td align="center">ostringstream</td>
<td align="center">向字符串中写入数据（输出流）</td>
<td align="center">ostream</td>
</tr>
<tr>
<td align="center">stringstream</td>
<td align="center">可读可写的字符串流</td>
<td align="center">iostream</td>
</tr>
</tbody></table>
<h4 id="常用的成员函数"><a href="#常用的成员函数" class="headerlink" title="常用的成员函数"></a>常用的成员函数</h4><table>
<thead>
<tr>
<th align="center">成员函数</th>
<th align="center">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.str()</td>
<td align="center">✅ 获取当前流中的字符串内容</td>
</tr>
<tr>
<td align="center">.str(“text”)</td>
<td align="center">✅ 设置（替换）流的字符串内容</td>
</tr>
<tr>
<td align="center">.clear()</td>
<td align="center">✅ 清除错误标志（如读取失败时必须调用才能继续用）</td>
</tr>
<tr>
<td align="center">.eof()</td>
<td align="center">检查是否读取到了字符串末尾</td>
</tr>
<tr>
<td align="center">.fail()</td>
<td align="center">检查是否发生错误（如类型不匹配读取失败）</td>
</tr>
<tr>
<td align="center">.good()</td>
<td align="center">检查流是否处于有效状态</td>
</tr>
<tr>
<td align="center">.seekg(pos)</td>
<td align="center">设置读取位置（get）指针</td>
</tr>
<tr>
<td align="center">.seekp(pos)</td>
<td align="center">设置写入位置（put）指针</td>
</tr>
<tr>
<td align="center">.tellg()</td>
<td align="center">返回当前读取位置</td>
</tr>
<tr>
<td align="center">.tellp()</td>
<td align="center">返回当前写入位置</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">向流中写入数据（流式写入）</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">从流中读取数据（流式提取）</td>
</tr>
</tbody></table>
<h4 id="istringstream-从字符串读取数据"><a href="#istringstream-从字符串读取数据" class="headerlink" title="istringstream - 从字符串读取数据"></a>istringstream - 从字符串读取数据</h4><h5 id="分割字符串，类型转换"><a href="#分割字符串，类型转换" class="headerlink" title="分割字符串，类型转换"></a>分割字符串，类型转换</h5><p>解析字符串中的数据，就像使用 cin 一样，你可以用 &gt;&gt; 操作符按顺序从字符串中读取内容，并自动转换数据类型，默认是以空格、换行、制表符等“空白字符”作为分隔符的。也可以使用getline()自定义分隔符。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">默认分隔符</th>
<th align="center">自定义分隔符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iss &gt;&gt; var</td>
<td align="center">空格、换行、制表</td>
<td align="center">❌ 不支持</td>
</tr>
<tr>
<td align="center">getline(iss, s)</td>
<td align="center">换行（默认）</td>
<td align="center">✅ 可指定分隔符</td>
</tr>
<tr>
<td align="center">getline(iss, s, ‘,’)</td>
<td align="center">任意字符</td>
<td align="center">✅ 自定义</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用 &gt;&gt; 读取，以空白字符作为分隔符</span></span><br><span class="line"><span class="comment">//输出 a=42, b=3.14, c=hello</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input = <span class="string">&quot;42 3.14 hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    string c;</span><br><span class="line"></span><br><span class="line">    iss &gt;&gt; a &gt;&gt; b &gt;&gt; c;     <span class="comment">//字符串 → int / float / double，能转换才能转换</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用getline()读取，可自定义分隔符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string item;</span><br><span class="line">    <span class="comment">//自定义，为分隔符</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss, item, <span class="string">&#x27;,&#x27;</span>)) &#123;   </span><br><span class="line">        cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ostringstream-向字符串中写入内容"><a href="#ostringstream-向字符串中写入内容" class="headerlink" title="ostringstream - 向字符串中写入内容"></a>ostringstream - 向字符串中写入内容</h4><h5 id="拼接多个变量为字符串，类型转换"><a href="#拼接多个变量为字符串，类型转换" class="headerlink" title="拼接多个变量为字符串，类型转换"></a>拼接多个变量为字符串，类型转换</h5><p>ostringstream 是 C++ <sstream> 头文件中的一个类，用来将数据格式化写入字符串，就像用 cout 向屏幕输出一样，不过输出的目标是一个 string。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 ID: 42, Score: 98.5, Name: Alice</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ostringstream oss;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> score = <span class="number">98.5</span>;</span><br><span class="line">    string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name;      <span class="comment">//int / float / double → 字符串</span></span><br><span class="line"></span><br><span class="line">    string result = oss.<span class="built_in">str</span>();  <span class="comment">// 获取最终生成的字符串</span></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stringstream-可读可写字符串流"><a href="#stringstream-可读可写字符串流" class="headerlink" title="stringstream - 可读可写字符串流"></a>stringstream - 可读可写字符串流</h4><p>它内部维护着一个字符串缓存（类似一个文本盒子），你可以先用 &lt;&lt; 写入内容，再用 &gt;&gt; 提取数据，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;100 3.14 hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    string c;</span><br><span class="line">    ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; endl;        <span class="comment">//100, 3.14, hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拆解 + 格式化写入</span></span><br><span class="line">string data = <span class="string">&quot;Tom 18 89.5&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line"></span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">float</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line">ss &gt;&gt; name &gt;&gt; age &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空流 &amp; 写</span></span><br><span class="line">ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空内容</span></span><br><span class="line">ss.<span class="built_in">clear</span>();  <span class="comment">// 清除状态</span></span><br><span class="line"></span><br><span class="line">ss &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;，成绩：&quot;</span> &lt;&lt; score;</span><br><span class="line">cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="格式化IO控制"><a href="#格式化IO控制" class="headerlink" title="格式化IO控制"></a>格式化IO控制</h2><p>C++ 提供了一组格式控制工具，来控制输出内容的 对齐方式、小数精度、进制、填充字符等。<br>这些方式定义在 头文件<br>#include <iomanip>  &#x2F;&#x2F; 提供格式控制符</p>
<table>
<thead>
<tr>
<th align="center">控制符</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">std::setw(n)</td>
<td align="center">设置字段宽度，默认右对齐（需要 <iomanip>）</td>
<td align="center">cout &lt;&lt; setw(10) &lt;&lt; 123;</td>
</tr>
<tr>
<td align="center">std::setfill(char)</td>
<td align="center">设置填充字符（配合 setw 使用）</td>
<td align="center">cout &lt;&lt; setfill(‘*’) &lt;&lt; setw(5) &lt;&lt; 1;</td>
</tr>
<tr>
<td align="center">std::setprecision(n)</td>
<td align="center">设置浮点数有效数字&#x2F;小数位</td>
<td align="center">cout &lt;&lt; setprecision(3) &lt;&lt; pi;</td>
</tr>
<tr>
<td align="center">std::fixed</td>
<td align="center">以固定小数格式输出（配合 setprecision）</td>
<td align="center">cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; pi;</td>
</tr>
<tr>
<td align="center">std::scientific</td>
<td align="center">科学计数法</td>
<td align="center">cout &lt;&lt; scientific &lt;&lt; pi;</td>
</tr>
<tr>
<td align="center">std::left &#x2F; std::right</td>
<td align="center">设置对齐方式（默认右对齐）</td>
<td align="center">cout &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; x;</td>
</tr>
<tr>
<td align="center">std::hex &#x2F; std::dec &#x2F; std::oct</td>
<td align="center">设置整数的输出进制</td>
<td align="center">cout &lt;&lt; hex &lt;&lt; 255;</td>
</tr>
<tr>
<td align="center">std::showbase</td>
<td align="center">显示进制前缀（如 0x, 0）</td>
<td align="center">cout &lt;&lt; showbase &lt;&lt; hex &lt;&lt; 255;</td>
</tr>
<tr>
<td align="center">std::showpos</td>
<td align="center">输出正号（+）</td>
<td align="center">cout &lt;&lt; showpos &lt;&lt; 123;</td>
</tr>
<tr>
<td align="center">std::noshowpos</td>
<td align="center">关闭正号显示</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">默认输出: 3.14159</span></span><br><span class="line"><span class="comment">固定精度输出: 3.14</span></span><br><span class="line"><span class="comment">科学计数法: 3.14e+00</span></span><br><span class="line"><span class="comment">-------123</span></span><br><span class="line"><span class="comment">hello-----world</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.141592653</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;默认输出: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;固定精度输出: &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;科学计数法: &quot;</span> &lt;&lt; scientific &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="number">123</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="string">&quot;world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO%E5%BA%93/" data-id="cmdohx9h1000030w8cicgd60w" data-title="IO库" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/14/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2025-04-14T09:17:17.705Z" itemprop="datePublished">2025-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/14/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB/">类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量（只能在类内部访问）</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（创建对象时自动调用）</span></span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数：输出信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello, my name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, and I am &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取年龄</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">sayHello</span>();</span><br><span class="line"></span><br><span class="line">    p<span class="number">1.</span><span class="built_in">setAge</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;New age: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员变量的类内初始值"><a href="#成员变量的类内初始值" class="headerlink" title="成员变量的类内初始值"></a>成员变量的类内初始值</h2><p>在定义成员变量时，直接为它赋一个初始值，必须以&#x3D;拷贝初始化或者花括号直接初始化的形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name = <span class="string">&quot;Unknown&quot;</span>;  <span class="comment">// 类内初始值</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;              <span class="comment">// 类内初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你没有在构造函数中为这些成员赋新值，它们就会使用这些默认值。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">show</span>();  <span class="comment">// 输出：Name: John Doe, Age: 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在构造函数里写了初始化，就会覆盖类内默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;  <span class="comment">// 覆盖初始值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">show</span>();  <span class="comment">// 输出：Alice, 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义一个类型成员"><a href="#定义一个类型成员" class="headerlink" title="定义一个类型成员"></a>定义一个类型成员</h2><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名，类型别名也一样存在访问限制。<br>定义类型成员必须先定义后使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> PublicType = <span class="type">int</span>;</span><br><span class="line">    ProtectedType j;        <span class="comment">//错误，定义类型成员必须先定义后使用</span></span><br><span class="line">    PrivateType l;      <span class="comment">//错误，定义类型成员必须先定义后使用</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> ProtectedType = <span class="type">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> PrivateType = <span class="type">char</span>;</span><br><span class="line">    PublicType k;</span><br><span class="line">    ProtectedType j;</span><br><span class="line">    PrivateType l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::PublicType x = <span class="number">10</span>;      <span class="comment">// ✅ 可以访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyClass::ProtectedType y = 3.14;  // ❌ 编译错误，protected</span></span><br><span class="line">    <span class="comment">// MyClass::PrivateType z = &#x27;A&#x27;;     // ❌ 编译错误，private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>常量成员函数是在函数定义后面加上 const 关键字的成员函数，它告诉编译器：这个函数不会修改当前对象的任何成员变量（除非它们是 mutable）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Person </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hi, I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// name = &quot;Bob&quot;; ❌ 错误：不能修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        age = a;       <span class="comment">//正确，普通成员函数可以修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const 对象只能调用 const 成员函数,但非常量对象可以调用 const 成员函数，也可以调用 非const 成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Person <span class="title">p</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">introduce</span>();   <span class="comment">// ✅ OK</span></span><br><span class="line">    <span class="comment">// p.setAge(30);  // ❌ 报错：不能调用非 const 成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用 mutable 修饰成员变量，让它在 const 函数中也能修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        accessCount++;  <span class="comment">// ✅ 这是合法的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="const成员函数返回-this"><a href="#const成员函数返回-this" class="headerlink" title="const成员函数返回 *this"></a>const成员函数返回 *this</h4><p>不希望调用者修改返回的当前对象，this 是一个 const ClassName* 指针，*this 的类型是 const ClassName&amp;，函数的返回类型必须是返回一个常量对象的引用。常用于只读链式调用、输出、调试、查询类函数，提升代码可读性和流畅性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; t, <span class="type">const</span> std::string&amp; a)</span><br><span class="line">        : <span class="built_in">title</span>(t), <span class="built_in">author</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 const Book&amp;（当前对象的常量引用），支持链式调用</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Book&amp; <span class="title">getTitle</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; title &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// const成员函数中 *this 是 const Book&amp;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Book&amp; <span class="title">getAuthor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Author: &quot;</span> &lt;&lt; author &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string title;</span><br><span class="line">    std::string author;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Book <span class="title">b</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>, <span class="string">&quot;Lippman&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用，连续打印信息，更加清楚的了解工作次序。</span></span><br><span class="line">    b.<span class="built_in">getTitle</span>().<span class="built_in">getAuthor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//b.getTitle();</span></span><br><span class="line">    <span class="comment">//b.getAuthor();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：不能修改返回值（因为返回的是 const 引用）</span></span><br><span class="line">    <span class="comment">// b.getTitle() = Book(&quot;Other&quot;, &quot;Someone&quot;);  // ❌ 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="const成员函数的重载"><a href="#const成员函数的重载" class="headerlink" title="const成员函数的重载"></a>const成员函数的重载</h4><p>由上面可知，常量对象只能调用常量成员函数，非常量对象可以调用常量、非常量成员函数，但非常量是一个更匹配的结果。实现const成员函数的重载就能根据对象是否是 const，自动调用合适的版本。<br>原理为 非 const 函数的 this 是：MyClass*， const 函数的 this 是：const MyClass*</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[非const] &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[const] &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sample a;</span><br><span class="line">    <span class="type">const</span> Sample b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a.<span class="built_in">getValue</span>() &lt;&lt; endl;  <span class="comment">// 调用非 const 版本</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b.<span class="built_in">getValue</span>() &lt;&lt; endl;  <span class="comment">// 调用 const 版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">[非const] a: 100</span></span><br><span class="line"><span class="comment">[const] b: 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="在类的外部定义成员函数和构造函数"><a href="#在类的外部定义成员函数和构造函数" class="headerlink" title="在类的外部定义成员函数和构造函数"></a>在类的外部定义成员函数和构造函数</h4><p>通常在类的外部定义成员函数和构造函数，以保持类的声明简洁清晰。这种方式也便于把头文件和实现文件分开。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.h （头文件）：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a);       <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 成员函数声明,const 修饰要保持一致	如果类中声明用了 const，外部定义也必须加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span></span>;            <span class="comment">// 成员函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person.cpp （源文件）：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 👉 在类外定义构造函数</span></span><br><span class="line">Person::<span class="built_in">Person</span>(string n, <span class="type">int</span> a) &#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 在类外定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::introduce</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hi, I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">introduce</span>();</span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">30</span>);</span><br><span class="line">    p.<span class="built_in">introduce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>与类同名的特殊成员函数；没有返回类型（连 void 都没有）；在创建对象时自动调用一次；用于给成员变量赋初值、准备资源等。<br>构造函数不能是const</p>
<h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><p>在构造函数的参数列表之后、函数体之前，用冒号 : 列出要初始化的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名(参数列表) : 成员<span class="number">1</span>(值<span class="number">1</span>), 成员<span class="number">2</span>(值<span class="number">2</span>), ... &#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const成员变量、引用成员变量或成员是没有默认构造函数的类对象必须使用初始值列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;  <span class="comment">// ✅ OK：必须用初始值列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Demo</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        x = val;  <span class="comment">// ❌ 错误：const 成员不能在构造函数体内赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>&amp; r) : <span class="built_in">ref</span>(r) &#123;&#125;  <span class="comment">// ✅ 引用必须在初始化列表中初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员是没有默认构造函数的类对象,合成的默认构造函数也没有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine;  <span class="comment">// ❗️Engine 没有默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>() &#123;</span><br><span class="line">        engine = <span class="built_in">Engine</span>(<span class="number">100</span>);  <span class="comment">// ❌ 错误：engine 必须在创建时就初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化列表的初始化顺序是按照成员在类中出现的顺序，而不是你写在初始化列表的顺序！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">b</span>(<span class="number">2</span>), <span class="built_in">a</span>(<span class="number">1</span>) &#123;  <span class="comment">// 看起来先初始化 b，再初始化 a？,但是a 在类中先声明，所以它会被先初始化！</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>不带任何参数（或所有参数都有默认值）的构造函数，用于创建对象时不传任何值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值的构造函数也算“默认构造函数”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> w = <span class="number">0</span>, <span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;  <span class="comment">// ✅ 等效默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你什么构造函数都没写，编译器会自动生成一个空的默认构造函数。这个自动生成的函数就叫 合成的默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;叫声！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal a;  <span class="comment">// 自动调用编译器提供的默认构造函数</span></span><br><span class="line">    a.<span class="built_in">sound</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你写了其它有参构造函数，默认构造函数就不会再自动生成，如果还想支持无参构造，你得手动写一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string n) : <span class="built_in">name</span>(n) &#123;&#125;  <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>() : <span class="built_in">name</span>(<span class="string">&quot;Unknown&quot;</span>) &#123;&#125;  <span class="comment">// ✅ 手动添加默认构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>() = <span class="keyword">default</span>;        <span class="comment">//等价默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><p>委托构造函数就是一种在构造函数中“调用自己”的方式，用于减少代码重复，统一初始化逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    类名(参数列表) : 类名(其它参数列表) &#123;</span><br><span class="line">        <span class="comment">// 可选的其他初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;主构造函数被调用\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">Person</span>(<span class="string">&quot;未知&quot;</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;委托构造函数被调用\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 年龄：&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;     <span class="comment">// 调用的是无参构造函数（但它委托给了带参构造）</span></span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主构造函数被调用</span></span><br><span class="line"><span class="comment">委托构造函数被调用</span></span><br><span class="line"><span class="comment">姓名：未知, 年龄：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h2><table>
<thead>
<tr>
<th align="center">访问说明符</th>
<th align="center">访问权限</th>
<th align="center">常用于</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">公开访问，任何地方都可以访问</td>
<td align="center">对外开放的接口函数、常用操作</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">受保护，类内和子类可访问</td>
<td align="center">继承相关、内部接口</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">私有，只有类内可以访问</td>
<td align="center">数据成员、内部函数，默认权限</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public 成员可以被外部随意访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is barking!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    d.name = <span class="string">&quot;Buddy&quot;</span>;  <span class="comment">// ✅ 可以直接访问</span></span><br><span class="line">    d.<span class="built_in">bark</span>();          <span class="comment">// ✅ 可以调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//protected 只能在类内或子类中访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;  <span class="comment">// ✅ 可以访问 protected 成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value = &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child c;</span><br><span class="line">    c.<span class="built_in">setValue</span>(<span class="number">42</span>);     <span class="comment">// ✅ 使用 public 接口设置</span></span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// c.value = 10;    ❌ 错误，外部不能访问 protected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private 成员只能类内部访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> balance;  <span class="comment">// 私有：外部不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Balance: &quot;</span> &lt;&lt; balance &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BankAccount acc;</span><br><span class="line">    <span class="comment">// acc.balance = 1000; ❌ 错误，balance 是 private</span></span><br><span class="line">    acc.<span class="built_in">deposit</span>(<span class="number">1000</span>);  <span class="comment">// ✅ 可以通过公有方法间接操作</span></span><br><span class="line">    acc.<span class="built_in">showBalance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="class与struct关键字"><a href="#class与struct关键字" class="headerlink" title="class与struct关键字"></a>class与struct关键字</h2><p>类可以在它的第一个访问说明符前定义成员，对这种成员的访问权限依赖于类定义的方式，如果使用struct关键字，则在第一个访问说明符前定义的成员默认是public，如果使用的class关键字，则这些成员是private，这也是class与struct关键字唯一的区别。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元（friend）是一个可以访问类中私有（private）或受保护（protected）成员的“外部函数或类”。<br>有时候，某些函数或类需要访问另一个类的私有成员，但你又不想把这些成员都设为 public，这时就可以让它成为“朋友”。<br>友元声明只能出现在类定义的内部，但在类内出现的具体位置不限，友元不是类的成员，也不受访问控制级别的约束，一般来说最好在类定义的开始或结束的位置集中声明友元。<br>友元声明并非普通意义上的声明，在调用此函数或类时，必须在之前真正声明过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//friend函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="comment">// 声明友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printLength</span><span class="params">(Box b)</span></span>;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> l) : <span class="built_in">length</span>(l) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义，可以访问 Box 的私有成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLength</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length = &quot;</span> &lt;&lt; b.length &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printLength</span>(box);  <span class="comment">// ✅ 能访问私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//friend类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="comment">// 声明 Car 为友元类</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Car</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> power = <span class="number">150</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showEnginePower</span><span class="params">(Engine e)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Engine Power: &quot;</span> &lt;&lt; e.power &lt;&lt; <span class="string">&quot; hp&quot;</span> &lt;&lt; endl;  <span class="comment">// ✅ 访问 private 成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Engine e;</span><br><span class="line">    Car c;</span><br><span class="line">    c.<span class="built_in">showEnginePower</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他类的成员函数作为friend</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明 B 类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::display</span><span class="params">(A&amp; a)</span></span>;  <span class="comment">// 声明 B::display() 为友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(A&amp; a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&#x27;s private value: &quot;</span> &lt;&lt; a.x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">display</span>(a);  <span class="comment">// 友元函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>表示 当前对象的指针。可以理解为：当你在类的成员函数中使用 this，它代表正在调用该函数的那个对象本身。</p>
<h4 id="隐式this"><a href="#隐式this" class="headerlink" title="隐式this"></a>隐式this</h4><p>在成员函数内部，编译器会自动把 this-&gt; 补上，使得类的成员函数内部可以直接访问当前对象的成员变量和其他成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) &#123;</span><br><span class="line">        name = n;  <span class="comment">// 等价于 this-&gt;name = n;</span></span><br><span class="line">        age = a;   <span class="comment">// 等价于 this-&gt;age = a;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以直接访问成员变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以直接调用其他成员函数</span></span><br><span class="line">        <span class="built_in">celebrateBirthday</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">celebrateBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Happy Birthday! Now I&#x27;m &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="显式this"><a href="#显式this" class="headerlink" title="显式this"></a>显式this</h4><h5 id="区分参数和成员变量同名（构造函数常见）"><a href="#区分参数和成员变量同名（构造函数常见）" class="headerlink" title="区分参数和成员变量同名（构造函数常见）"></a>区分参数和成员变量同名（构造函数常见）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;  <span class="comment">// 如果不写 this-&gt;name = name; 就只是给自己赋值自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;  <span class="comment">// 可写可不写 this-&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="支持链式调用（返回-this）"><a href="#支持链式调用（返回-this）" class="headerlink" title="支持链式调用（返回 *this）"></a>支持链式调用（返回 *this）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;     <span class="comment">//默认构造函数，使用初始化列表将 count 设置为 0。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Counter&amp; <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count++;  <span class="comment">//this-&gt;count 就是访问当前对象的 count 成员。使得count+1</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 显式返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    c.<span class="built_in">increment</span>().<span class="built_in">increment</span>().<span class="built_in">increment</span>().<span class="built_in">print</span>();  <span class="comment">// 链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c.increment()：第一次自增，count = 1；</span></span><br><span class="line"><span class="comment">.increment()：第二次自增，count = 2；</span></span><br><span class="line"><span class="comment">.increment()：第三次自增，count = 3；</span></span><br><span class="line"><span class="comment">.print()：打印当前值，输出 Count: 3。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="模板类中必须用-this"><a href="#模板类中必须用-this" class="headerlink" title="模板类中必须用 this-&gt;"></a>模板类中必须用 this-&gt;</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = v;  <span class="comment">// 必须写 this-&gt;value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; endl;  <span class="comment">// 同样需要 this-&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="名字查找"><a href="#名字查找" class="headerlink" title="名字查找"></a>名字查找</h2><p>当你在代码中使用一个名字（如变量名、函数名、类名等），编译器会按一定的规则依次在不同的作用域中查找它的定义：<br>最内层作用域 → 外层作用域 → 类作用域 → 命名空间作用域 → 全局作用域</p>
<h4 id="普通变量查找"><a href="#普通变量查找" class="headerlink" title="普通变量查找"></a>普通变量查找</h4><p>编译器优先查找最近的作用域（局部作用域）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 输出 20，使用的是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类成员变量查找"><a href="#类成员变量查找" class="headerlink" title="类成员变量查找"></a>类成员变量查找</h4><p>成员名字的查找会从当前类开始，逐级向基类查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;      <span class="comment">// 输出 10，使用 B::x</span></span><br><span class="line">        cout &lt;&lt; A::x &lt;&lt; endl;   <span class="comment">// 使用作用域解析访问 A::x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="成员使用类型名的处理"><a href="#成员使用类型名的处理" class="headerlink" title="成员使用类型名的处理"></a>成员使用类型名的处理</h4><p>如果成员使用了外层作用域中的某个名字，这个名字是一种类型的别名，则类不能在之后重新定义该名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T = <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    T value;      <span class="comment">// ✅ 这里的 T 指的是外部的类型别名 int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> T = <span class="type">int</span>;  <span class="comment">//  ❌ 错误！不能在类内部将 T 重新定义</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;        <span class="comment">// ❌ 错误！不能在类内部将 T 重新定义为变量或成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="成员函数中名字查找"><a href="#成员函数中名字查找" class="headerlink" title="成员函数中名字查找"></a>成员函数中名字查找</h4><p>首先，在成员函数内查找该名字的声明，包括参数，在使用该名字之前声明才被考虑<br>如果在成员函数中没有找到，则在类中继续查找，由于类是先编译成员的声明，直到类全部可见后才编译函数体，所以这是类中所有成员都可以被考虑<br>如果在类中也没找到，则在成员函数定义之前的作用域内继续查找。</p>
<h2 id="隐式类类型转换"><a href="#隐式类类型转换" class="headerlink" title="隐式类类型转换"></a>隐式类类型转换</h2><p>当编译器在表达式中遇到类型不匹配，但可以通过某些构造函数或转换函数让类型自动变换时，它会进行 隐式转换，即你不写任何转换代码，编译器自动帮你转换。</p>
<h4 id="构造函数触发的隐式转换-其他类型转化成类类型"><a href="#构造函数触发的隐式转换-其他类型转化成类类型" class="headerlink" title="构造函数触发的隐式转换 -&gt; 其他类型转化成类类型"></a>构造函数触发的隐式转换 -&gt; 其他类型转化成类类型</h4><p>构造函数 只有一个参数，或剩下的参数都有默认值；<br>构造函数 没有被 explicit 限制；<br>编译器尝试将其他类型转为该类类型时，自动调用该构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNumber</span>(<span class="type">int</span> x) &#123; cout &lt;&lt; <span class="string">&quot;构造 MyNumber(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumber</span><span class="params">(MyNumber n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;打印数字\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumber</span>(<span class="number">100</span>);  <span class="comment">// 👈 int 隐式转为 MyNumber</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换运算符（operator-类型-）-类类型转化成其他类型"><a href="#类型转换运算符（operator-类型-）-类类型转化成其他类型" class="headerlink" title="类型转换运算符（operator 类型()）-&gt; 类类型转化成其他类型"></a>类型转换运算符（operator 类型()）-&gt; 类类型转化成其他类型</h4><p>可以让对象自动转换为别的类型，方法是在类中写一个 类型转换函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNumber</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 👈 允许隐式转为 double</span></span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyNumber <span class="title">n</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="type">double</span> d = n;  <span class="comment">// 👈 隐式转换调用 operator double()</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="explicit关键字与显示类类型转换"><a href="#explicit关键字与显示类类型转换" class="headerlink" title="explicit关键字与显示类类型转换"></a>explicit关键字与显示类类型转换</h2><p>在没有 explicit 的情况下，C++ 会允许构造函数和类型转换函数自动触发隐式转换，这虽然方便，但有时可能引起逻辑歧义或代码难以阅读&#x2F;维护的问题。</p>
<h4 id="explicit-修饰-构造函数"><a href="#explicit-修饰-构造函数" class="headerlink" title="explicit 修饰 构造函数"></a>explicit 修饰 构造函数</h4><p>禁止自动将其他类型转换为该类类型。可以显示构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;打印 A 对象\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printA</span>(<span class="number">10</span>);          <span class="comment">// ❌ 错误：不能隐式把 int 转为 A</span></span><br><span class="line">    <span class="built_in">printA</span>(<span class="built_in">A</span>(<span class="number">10</span>));       <span class="comment">// ✅ 正确：显式构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="explicit-修饰-类型转换函数"><a href="#explicit-修饰-类型转换函数" class="headerlink" title="explicit 修饰 类型转换函数"></a>explicit 修饰 类型转换函数</h4><p>禁止自动将当前类类型转换为其他类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">x</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = b;                   <span class="comment">// ❌ 错误：不能隐式转换为 int</span></span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(b); <span class="comment">// ✅ 正确：显式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="static-cast-显示类型转换"><a href="#static-cast-显示类型转换" class="headerlink" title="static_cast 显示类型转换"></a>static_cast 显示类型转换</h4><p>static_cast<T>(expr) 是 C++ 中的 显式类型转换操作，用来进行类型之间的安全转换。和旧式的 C 风格强转 (int)b 相比，它更类型安全、更容易搜索和维护。<br>只要你写了 explicit operator 类型()，你就必须用 static_cast&lt;类型&gt;(对象) 这种方式去调用。</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>静态成员是属于类本身而不是类的某个具体对象的成员，可以是：<br>静态成员变量（数据成员）<br>静态成员函数（函数成员）<br>成员函数可以直接访问静态成员</p>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>静态成员变量属于类，类的所有对象共享一个静态变量，它的生命周期为从程序开始直到结束，需要在类外定义一次，可以通过对象访问，也可以通过类名访问，支持访问权限控制可设置为 public &#x2F; private &#x2F; protected。</p>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员变量声明</span></span><br><span class="line">    <span class="type">static</span> 数据类型 变量名;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员变量声明：用于统计对象数量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>传统写法（C++11 及以前）：不可以类内定义，只能类外定义。<br>现代写法（C++17 及以后）：可以在类内用 inline 定义并初始化，不用类外定义<br>注意类外定义不加static</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++11</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;  <span class="comment">// 只能声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::x = <span class="number">0</span>;  <span class="comment">// 必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c++17</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// C++17及以后合法，类内定义并初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>可以使用作用域运算符直接访问静态成员，也可以通过对象访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Counter</span>() &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Counter::count = <span class="number">0</span>;  <span class="comment">// 静态变量在类外定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用类名访问： &quot;</span> &lt;&lt; Counter::count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Counter b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用对象访问： &quot;</span> &lt;&lt; b.count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态数据成员的类型可以就是它所属的类类型"><a href="#静态数据成员的类型可以就是它所属的类类型" class="headerlink" title="静态数据成员的类型可以就是它所属的类类型"></a>静态数据成员的类型可以就是它所属的类类型</h5><p>非静态成员不能是自身类型（无限嵌套）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> A example;  <span class="comment">// 声明：静态成员是类本身</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义（必须这样）</span></span><br><span class="line">A A::example;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::example.<span class="built_in">sayHello</span>();  <span class="comment">// 使用静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态成员作为默认实参"><a href="#静态成员作为默认实参" class="headerlink" title="静态成员作为默认实参"></a>静态成员作为默认实参</h5><p>只要静态成员在使用它作为默认实参时已经声明可见（即作用域中能找到它），就可以作为默认实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> defaultValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = defaultValue)</span> </span>&#123;  <span class="comment">// ✅ 用静态成员作为默认参数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义静态成员</span></span><br><span class="line"><span class="type">int</span> A::defaultValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">func</span>();        <span class="comment">// 输出：x = 42</span></span><br><span class="line">    a.<span class="built_in">func</span>(<span class="number">100</span>);     <span class="comment">// 输出：x = 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果调换顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = defaultValue)</span></span>;  <span class="comment">// ❌ 错误：defaultValue 尚未声明</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> defaultValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>不依赖任何对象实例,因为没有 this 指针,不能访问非静态成员变量或函数,但可以访问静态成员变量</p>
<h5 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h5><p>注意静态成员函数不能声明成const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数声明</span></span><br><span class="line">    <span class="type">static</span> 返回类型 函数名(参数列表);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>类内类外都可定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类内定义静态函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">greet</span><span class="params">()</span></span>;  <span class="comment">// 类内只声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello::greet</span><span class="params">()</span> </span>&#123;      <span class="comment">// 类外定义</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello from outside!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>可以使用类名调用，或使用对象调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// C++17 写法（类内初始化）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">showCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前对象数: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter::<span class="built_in">showCount</span>();  <span class="comment">// 输出：当前对象数: 0</span></span><br><span class="line"></span><br><span class="line">    Counter a, b;</span><br><span class="line">    Counter::<span class="built_in">showCount</span>();  <span class="comment">// 输出：当前对象数: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用对象调用（虽然不推荐）</span></span><br><span class="line">    a.<span class="built_in">showCount</span>();         <span class="comment">// 输出：当前对象数: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不完全类型"><a href="#不完全类型" class="headerlink" title="不完全类型"></a>不完全类型</h2><p>一个类型被声明了，但其完整定义尚不可见，此时它就是“不完全”的。<br>指针，引用可以是不完全类型</p>
<pre><code class="language-c++">class B;  // 前向声明,B 是不完全类型

class A &#123;
    B* ptr;  // ✅ 可以用指针

    void func(B&amp; b);  // ✅ 合法，引用不完全类型作为参数

    B obj; // ❌ 错误，B 还是不完全类型，不能创建对象

    B b;           // ❌ 错误，B 是不完全类型，无法创建对象

    B&amp; ref = b;    // ❌ 错误，因为 b 无法创建

&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/14/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB/" data-id="cmdohx9hm000c30w8a1ega96a" data-title="类" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学习笔记/函数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/09/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2025-04-09T13:40:58.585Z" itemprop="datePublished">2025-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/09/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/">函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数只能定义一次，但可以声明多次。函数声明包括返回类型、函数名、形参类型，不包含函数体，也无需形参的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> [])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> [<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>可以简化看成 形参 &#x3D; 实参; 是否符合赋值逻辑规则。</p>
<h4 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1.值传递"></a>1.值传递</h4><p>传进去的是实参的副本，函数内部修改不影响外部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">foo</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 输出：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-引用传递"><a href="#2-引用传递" class="headerlink" title="2.引用传递"></a>2.引用传递</h4><p>传进去的是实参的别名，可以在函数中直接修改原变量，如果函数无需改变引用形参的值，最好将其声明为常量引用。<br>const 引用传递（推荐用于大型对象）不拷贝、不可修改，节省内存、防止误改。<br>具体见引用.md</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">too</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">too</span>(a);             <span class="comment">//输出5</span></span><br><span class="line">    <span class="built_in">foo</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 输出：100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-指针传递"><a href="#3-指针传递" class="headerlink" title="3.指针传递"></a>3.指针传递</h4><p>等价于引用，但需要解引用。可以修改实参的值，并且减少内存拷贝，提升性能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">    *x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">too</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *x)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; *x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">too</span>(&amp;a);        <span class="comment">//输出5</span></span><br><span class="line">    <span class="built_in">foo</span>(&amp;a);  <span class="comment">// 传地址</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 输出：100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-数组传递"><a href="#4-数组传递" class="headerlink" title="4.数组传递"></a>4.数组传递</h4><p>因为不允许拷贝数组以及使用数组通常会转换成指针，所以无法用值传递使用数组参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组形参为指向const的指针，表示不修改原数组。以下三种写法等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> [])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> [<span class="number">10</span>])</span></span>;       <span class="comment">//维度表示期望数组含有多少元素，但可以不满足</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line"><span class="type">int</span> j[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);      <span class="comment">//正确 const int *a = &amp;i; 非常量可以转换常量</span></span><br><span class="line"><span class="built_in">print</span>(j);       <span class="comment">//正确 类似const int *a = j;但是实际上数组不能赋值 非常量可以转换常量</span></span><br></pre></td></tr></table></figure>
<h4 id="5-数组引用传递"><a href="#5-数组引用传递" class="headerlink" title="5.数组引用传递"></a>5.数组引用传递</h4><p>引用数组可以限制数组长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line"><span class="type">int</span> j[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> k[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);      <span class="comment">//错误，实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(j);       <span class="comment">//错误，实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(k);       <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h4 id="6-多维数组传递"><a href="#6-多维数组传递" class="headerlink" title="6.多维数组传递"></a>6.多维数组传递</h4><p>必须指定除第一维之外的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2D</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">3</span>], <span class="type">int</span> rows)</span></span>;      <span class="comment">//int (*arr)[3] 表示一个指向含3个int的数组的指针</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2D</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="7-initialzer-list形参"><a href="#7-initialzer-list形参" class="headerlink" title="7.initialzer_list形参"></a>7.initialzer_list<T>形参</h4><p>如果函数的实参数量未知，但是全部实参的类型都相同，可以使用initialzer_list<T>类型的形参。<br>initialzer_list<T>对象中的元素永远是常量值，只读不能修改元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);   <span class="comment">// 👈 传任意多个 int</span></span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">100</span>&#125;);            <span class="comment">// 👈 也可以只传一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="各种形参的使用场景"><a href="#各种形参的使用场景" class="headerlink" title="各种形参的使用场景"></a>各种形参的使用场景</h4><h5 id="如果不需要在函数中修改实参"><a href="#如果不需要在函数中修改实参" class="headerlink" title="如果不需要在函数中修改实参"></a>如果不需要在函数中修改实参</h5><ul>
<li>如果实参很小，如C++内置的数据类型或小型结构体，则按值传递。</li>
<li>如果实参是数组，则使用const指针，因为这是唯一的选择（没有为数组建立引用的说法）。</li>
<li>如果实参是较大的结构，则使用const指针或const引用。</li>
<li>如果实参是类，则使用const引用，传递类的标准方式是按引用传递（类设计的语义经常要求使用引用）。</li>
</ul>
<h5 id="如果需要修改实参"><a href="#如果需要修改实参" class="headerlink" title="如果需要修改实参"></a>如果需要修改实参</h5><ul>
<li>如果实参是内置数据类型，则使用指针。只要看到func(&amp;x)的调用，表示函数将修改x。</li>
<li>如果实参是数组，则只能使用指针。</li>
<li>如果实参是结构体，则使用指针或引用。</li>
<li>如果实参是类，则使用引用。</li>
</ul>
<h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>为了使得函数既能接纳默认值，也能接受传递的参数，在函数声明中为一个或多个形参提供默认参数，需要注意的是，一旦某个形参被赋予某个默认值，则它后面所有形参都必须有默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span> w = <span class="number">24</span>,<span class="type">char</span> = <span class="string">&#x27;&#x27;);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">string screen(int ,int w = 25,char = &#x27;</span>e<span class="string">&#x27;);      //错误，不能修改之前声明已经添加的默认值</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">string screen(int = 22,int w = 24,char = &#x27;</span><span class="string">&#x27;);   //正确，添加默认实参</span></span></span></span><br></pre></td></tr></table></figure>
<p>函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> = <span class="number">22</span>,<span class="type">int</span> w = <span class="number">24</span>,<span class="type">char</span> = <span class="string">&#x27;&#x27;);   //函数声明</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">//函数定义</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">string screen(int h,int w,char c)</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#123; </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">    return string(h,string(w,c));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">// 报错</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">string screen(int = 22,int w = 24,char = &#x27;</span><span class="string">&#x27;)</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">    return string(h,string(w,c));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window = <span class="built_in">screen</span>();      <span class="comment">//screen(22,24,&#x27;&#x27;);</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>);      <span class="comment">//screen(66,256,&#x27;&#x27;);</span></span><br><span class="line">window = <span class="built_in">screen</span>(,,<span class="string">&#x27;?&#x27;</span>);        <span class="comment">//错误，只能省略尾部的实参</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="string">&#x27;?&#x27;</span>);       <span class="comment">//错误 char与int不匹配</span></span><br></pre></td></tr></table></figure>
<p>局部变量不能作为默认实参，除此之外，只要表达式的类型能转成形参所需的类型，该表达式就能作为默认实参。<br>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。（也就是说，默认实参的声明必须在此函数声明之前，且与函数绑定，不会受到重名的影响，但默认实参的取值，是看调用此函数时的当前值。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//w, h(),def声明必须在函数声明前</span></span><br><span class="line"><span class="type">int</span> w = <span class="number">80</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">string screen(int = h(), int = w, char = def);     //在函数的作用域中，默认实参表达式名已经与函数绑定，不受其他作用域重名的影响</span></span><br><span class="line"><span class="string">string window = screen();       //等价于screen(h(),80,&#x27;</span><span class="string">&#x27;);</span></span><br><span class="line"><span class="string">void f()&#123;</span></span><br><span class="line"><span class="string">    def = &#x27;</span>@<span class="string">&#x27;;              //修改全局变量def的值</span></span><br><span class="line"><span class="string">    int w = 100;           //声明定义一个与全局变量重名的局部变量w</span></span><br><span class="line"><span class="string">    string window = screen();      //默认实参的取值，是看调用此函数时的当前值。等价于screen(h(),80,&#x27;</span>@<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><h4 id="常见的返回类型"><a href="#常见的返回类型" class="headerlink" title="常见的返回类型"></a>常见的返回类型</h4><table>
<thead>
<tr>
<th align="center">返回类型</th>
<th align="center">实例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">int func();</td>
<td align="center">返回单个值</td>
</tr>
<tr>
<td align="center">指针</td>
<td align="center">int *func();</td>
<td align="center">返回地址</td>
</tr>
<tr>
<td align="center">引用</td>
<td align="center">int &amp;func();</td>
<td align="center">返回别名（注意作用域！）</td>
</tr>
<tr>
<td align="center">类对象（值）</td>
<td align="center">std::string func();</td>
<td align="center">返回拷贝或移动</td>
</tr>
<tr>
<td align="center">类对象（常量引用）</td>
<td align="center">const std::string&amp; func();</td>
<td align="center">避免拷贝，提高性能</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">void func();</td>
<td align="center">不返回任何值</td>
</tr>
</tbody></table>
<h4 id="返回类型与返回值对照表"><a href="#返回类型与返回值对照表" class="headerlink" title="返回类型与返回值对照表"></a>返回类型与返回值对照表</h4><table>
<thead>
<tr>
<th align="center">返回类型</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">int 或 int 可转换的类型</td>
<td align="center">返回一个 int 类型的值。可以是常量、变量，或 int 类型的表达式结果。</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">double 或 int（隐式转换）</td>
<td align="center">返回一个 double 类型的值。如果返回的是 int，C++ 会自动将其转换为 double。</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">float 或 int（隐式转换）</td>
<td align="center">返回一个 float 类型的值。如果返回的是 int，C++ 会自动将其转换为 float。</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">char 或可以隐式转换为 char 的类型</td>
<td align="center">返回一个 char 类型的值。</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center">bool</td>
<td align="center">返回 true 或 false，或能够转换为布尔值的任何表达式。</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">无返回值</td>
<td align="center">函数的返回类型是 void 时，return 语句不能返回任何值。</td>
</tr>
<tr>
<td align="center">int*</td>
<td align="center">int* 或指向 int 的地址</td>
<td align="center">返回一个指向 int 类型的指针，通常是数组的地址、变量的地址，或者动态分配的内存的地址。</td>
</tr>
<tr>
<td align="center">int&amp;</td>
<td align="center">int&amp;（引用）</td>
<td align="center">返回一个 int 类型的引用，可以是局部变量（如果它是静态的），全局变量，或者对象的成员。</td>
</tr>
<tr>
<td align="center">const int&amp;</td>
<td align="center">const int&amp;（引用）</td>
<td align="center">返回一个 const 引用，表示返回的值不能被修改。通常用于返回临时对象的引用，避免不必要的拷贝。</td>
</tr>
</tbody></table>
<h4 id="返回值与返回引用"><a href="#返回值与返回引用" class="headerlink" title="返回值与返回引用"></a>返回值与返回引用</h4><p>俩return语句后跟的值相同，看返回类型为基本类型，就是返回某变量的值，返回类型为引用，就是返回某变量的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回value的值</span></span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;  <span class="comment">// 返回值的副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">getValue</span>();  <span class="comment">// 获取副本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Returned value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    val = <span class="number">20</span>;  <span class="comment">// 修改副本，不影响原值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回value的引用</span></span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;  <span class="comment">// 返回引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">getValue</span>();  <span class="comment">// 获取引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Returned value: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    ref = <span class="number">20</span>;  <span class="comment">// 通过引用修改原值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果你返回一个局部变量的引用，而该变量在函数结束后会被销毁（例如，局部变量），那么返回的引用会指向一个已销毁的对象，导致悬空引用。这是非常危险的，可能会导致未定义的行为。<br> 临时对象也会在表达式结束时销毁，因此不应返回临时对象的引用。<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">int</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;  <span class="comment">// 错误：返回局部变量的引用，temp 在函数结束后会被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h4><p>C++ 中不能直接返回数组，因为数组类型不是一个“可以整体返回”的值类型，正确方式为返回指向数组的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">getArray</span>())[<span class="number">10</span>] &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;  <span class="comment">// 静态数组，避免悬垂指针</span></span><br><span class="line">    <span class="keyword">return</span> &amp;arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">10</span>] = <span class="built_in">getArray</span>();  <span class="comment">// 获取数组指针</span></span><br><span class="line">    cout &lt;&lt; (*p)[<span class="number">2</span>] &lt;&lt; endl;    <span class="comment">// 输出第3个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef / using 简化</span></span><br><span class="line"><span class="keyword">using</span> IntArray10 = <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 定义别名：IntArray10 是长度为 10 的 int 数组</span></span><br><span class="line"><span class="function">IntArray10* <span class="title">getArray</span><span class="params">()</span> </span>&#123;                <span class="comment">//注意这是数组指针别名</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 静态数组，避免悬垂指针</span></span><br><span class="line">    <span class="keyword">return</span> &amp;arr;  <span class="comment">// 返回数组指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntArray10* p = <span class="built_in">getArray</span>();  <span class="comment">// 获取数组指针</span></span><br><span class="line">    cout &lt;&lt; (*p)[<span class="number">2</span>] &lt;&lt; endl;  <span class="comment">// 输出数组第 3 个元素（值为 3）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价写法</span></span><br><span class="line"><span class="keyword">using</span> IntArrayPtr = <span class="built_in">int</span> (*)[<span class="number">10</span>];</span><br><span class="line"><span class="function">IntArrayPtr <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 decltype</span></span><br><span class="line"><span class="comment">//如果我们知道函数返回的指针将指向哪个类型的数组，就可以使用decltype</span></span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(arr1) *<span class="built_in">getArray</span>(<span class="type">int</span> i) &#123;       <span class="comment">//decltype(arr1)返回int[3]</span></span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;arr1 : &amp;arr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价写法</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;arr1) <span class="built_in">getArray</span>(<span class="type">int</span> i) &#123;       <span class="comment">//decltype(&amp;arr1)返回int (*)[3]</span></span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;arr1 : &amp;arr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用尾置返回类型</span></span><br><span class="line"><span class="comment">//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h4><h5 id="初始化-std-vector（容器）"><a href="#初始化-std-vector（容器）" class="headerlink" title="初始化 std::vector（容器）"></a>初始化 std::vector（容器）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">createVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 使用列表初始化返回一个 std::vector&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = <span class="built_in">createVector</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::array&lt;<span class="type">int</span>, 5&gt; <span class="title">createArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 使用列表初始化返回一个 std::array&lt;int, 5&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = <span class="built_in">createArray</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">x</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyClass&#123;<span class="number">10</span>&#125;;  <span class="comment">// 使用列表初始化创建对象并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="built_in">createObject</span>();  <span class="comment">// 通过列表初始化返回的对象</span></span><br><span class="line">    obj.<span class="built_in">print</span>();  <span class="comment">// 输出：x = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。<br>使用函数指针的三个步骤：</p>
<ul>
<li>声明函数指针。<ul>
<li>函数类型  （指针名）（函数参数类型）</li>
</ul>
</li>
<li>让函数指针指向函数的地址（函数名就是函数的地址）。<ul>
<li>函数指针的赋值：函数指针名 &#x3D; 函数名;</li>
</ul>
</li>
<li>通过函数指针调用函数。<ul>
<li>(*函数指针名)(实参);  &#x2F;&#x2F;c语言</li>
<li>函数指针名(实参);   &#x2F;&#x2F;c++</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数指针，funcPtr指向一个函数，函数参数是俩个int类型，函数返回类型是int类型。</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向函数 函数类型与形参类型必须与指针相匹配</span></span><br><span class="line">funcPtr = &amp;add;</span><br><span class="line">funcPtr = add;          <span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数,三种等价</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">funcPtr</span>(<span class="number">3</span>, <span class="number">4</span>);  </span><br><span class="line"><span class="type">int</span> result = (*funcPtr)(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);     </span><br><span class="line">std::cout &lt;&lt; result;  <span class="comment">// 输出 7</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h4><p>可以把函数指针当作参数传给其他函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数是函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> (*operation)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">operation</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动将函数substract转换成指向该函数的指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">5</span>, <span class="number">3</span>, subtract);  <span class="comment">// 输出 Result: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数名为getFunction，返回类型为指向返回类型为int类型，形参为俩个int的函数的指针</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">getFunction</span>())(<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = <span class="built_in">getFunction</span>();         <span class="comment">//auto推导类型为int (*)(int, int)</span></span><br><span class="line"><span class="comment">//等价于int (*func)(int, int) = add；</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 输出 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数指针应用场景"><a href="#函数指针应用场景" class="headerlink" title="函数指针应用场景"></a>函数指针应用场景</h4><p>函数指针可以让通用逻辑可扩展。</p>
<ul>
<li><strong>有一个通用的函数（“模板函数”）</strong>：它做核心的流程，比如排序、遍历、处理事件、执行状态机等。</li>
<li><strong>但是流程中的某个步骤（比较、处理、回调）</strong>，是可变的，需要由用户自己决定。</li>
<li><strong>如果直接调用函数</strong>，那这个通用函数每次遇到新需求就得改内部逻辑（不断写 if&#x2F;else），或者复制粘贴不同版本，既麻烦又不灵活。</li>
<li><strong>用函数指针</strong>，只要把要执行的那部分逻辑外包出来，通过函数指针形参传进去，通用函数本身完全不用动。</li>
</ul>
<p><strong>用 qsort 举例对比</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">base 是数据的首地址</span></span><br><span class="line"><span class="comment">num 是元素个数</span></span><br><span class="line"><span class="comment">size 是每个元素的大小</span></span><br><span class="line"><span class="comment">compar 是比较函数指针 👉 用来告诉 qsort 怎么比较两个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> num, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>直接调用</strong><br>假设 qsort函数是直接调用比较函数来实现的。<br>那它必须要自己知道要按什么规则排，于是你只能把不同的比较逻辑都写死在函数内部，示例伪代码就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> num, <span class="type">size_t</span> size, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较函数：整数升序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较函数：整数降序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较函数：按名字排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你要支持更多排序方式，就要不停改 qsort 代码。</li>
<li>如果要支持自定义结构体、复杂比较，需要一直给 qsort 增加更多 if 分支。</li>
<li>用户没法自己扩展，只能等库作者帮你加</li>
</ul>
<p><strong>使用函数指针</strong><br>就可以把可变部分（比较规则）外包给用户：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> num, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己写一个比较函数，整数升序          </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmpInt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arg1 = *(<span class="type">const</span> <span class="type">int</span> *)a;</span><br><span class="line">    <span class="type">int</span> arg2 = *(<span class="type">const</span> <span class="type">int</span> *)b;</span><br><span class="line">    <span class="keyword">return</span> arg1 - arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    qsort 把比较步骤提取出来，只要你提供不同的比较函数：</span></span><br><span class="line"><span class="comment">    cmpInt：按整数升序</span></span><br><span class="line"><span class="comment">    cmpIntDesc：按整数降序</span></span><br><span class="line"><span class="comment">    qsort 自己的实现完全不用动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">qsort</span>(arr, n, <span class="built_in">sizeof</span>(<span class="type">int</span>), cmpInt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>qsort 本身只管排序的流程（分块、交换、递归），不关心你具体怎么比较两个元素。</li>
<li>用户想按什么比较，就自己写比较函数传进去。</li>
<li>不需要修改 qsort，只需要写新函数，传进去就完事。</li>
</ul>
<h4 id="使用-typedef-或-using-简化函数指针写法"><a href="#使用-typedef-或-using-简化函数指针写法" class="headerlink" title="使用 typedef 或 using 简化函数指针写法"></a>使用 typedef 或 using 简化函数指针写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个函数指针类型，指向返回 int、参数是 (int, int) 的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FuncType)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> *FuncType</span>;        <span class="comment">//decltype(add)* 得到的是函数类型：int (*)(int, int)</span></span><br><span class="line"><span class="comment">//定义了一个函数类型 func，它是：int(int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> func</span>;             <span class="comment">//decltype(add) 得到的是函数类型：int(int, int)</span></span><br><span class="line"><span class="comment">// 或者 C++11 起可以用 using</span></span><br><span class="line"><span class="keyword">using</span> FuncType = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">using</span> FuncType = <span class="keyword">decltype</span>(add)*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">decltype</span>(add);</span><br><span class="line"></span><br><span class="line">FuncType func = add;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个返回类型为函数指针（这个指针指向返回 int、参数是 (int, int) 的函数）名为f1，参数为int的函数。</span></span><br><span class="line"><span class="function">FuncType <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">func *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">func <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;       <span class="comment">//错误，func是函数类型无法作为f1的返回类型</span></span><br><span class="line"><span class="comment">//不用别名</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>,<span class="type">int</span>);\</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="auto-和-decltype-用于函数指针"><a href="#auto-和-decltype-用于函数指针" class="headerlink" title="auto 和 decltype 用于函数指针"></a>auto 和 decltype 用于函数指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = add;      <span class="comment">// 自动推导为：int (*)(int, int)</span></span><br><span class="line">    <span class="comment">//auto* func = add;更明确   等价于：int (*func)(int, int)</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; result;  <span class="comment">// 输出 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 函数类型（不是指针）</span></span><br><span class="line"><span class="keyword">decltype</span>(add) funcTypeFunc;  <span class="comment">// 声明一个函数，但不能定义变量（不完整）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数指针类型</span></span><br><span class="line"><span class="keyword">decltype</span>(add)* ptr = add;  <span class="comment">// 正确：decltype(add) 是函数类型，加 * 表示函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//搭配using</span></span><br><span class="line"><span class="keyword">using</span> FuncType = <span class="keyword">decltype</span>(add)*;  <span class="comment">// 定义函数指针类型</span></span><br><span class="line">FuncType fptr = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getFunction</span><span class="params">()</span> -&gt; <span class="title">decltype</span><span class="params">(add)</span>* </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">getFunction</span>();  <span class="comment">// 自动推导为：int (*)(int, int)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出 7</span></span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载是指设计一系列同名函数，让它们完成相同（似）的工作。<br>C++允许定义名称相同的函数，条件是它们的特征（形参的个数、数据类型和排列顺序）不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">short</span> a,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,string b, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(string b, <span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。</p>
<h4 id="函数重载的特征"><a href="#函数重载的特征" class="headerlink" title="函数重载的特征"></a>函数重载的特征</h4><h5 id="参数个数不同"><a href="#参数个数不同" class="headerlink" title="参数个数不同"></a>参数个数不同</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;          <span class="comment">// 无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;       <span class="comment">// 一个参数</span></span><br></pre></td></tr></table></figure>
<h5 id="参数类型不同"><a href="#参数类型不同" class="headerlink" title="参数类型不同"></a>参数类型不同</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="参数顺序不同（类型顺序不同）"><a href="#参数顺序不同（类型顺序不同）" class="headerlink" title="参数顺序不同（类型顺序不同）"></a>参数顺序不同（类型顺序不同）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="参数是否是引用类型-const-引用类型不同"><a href="#参数是否是引用类型-const-引用类型不同" class="headerlink" title="参数是否是引用类型 &#x2F; const 引用类型不同"></a>参数是否是引用类型 &#x2F; const 引用类型不同</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;           <span class="comment">// 只能接受非常量左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;     <span class="comment">// 可以接受常量、右值、表达式等</span></span><br></pre></td></tr></table></figure>
<h4 id="函数重载的注意事项"><a href="#函数重载的注意事项" class="headerlink" title="函数重载的注意事项"></a>函数重载的注意事项</h4><p>使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);  <span class="comment">// ❌ 编译错误！因为 3.14 可以转成 int 或 char，但编译器不知道选哪个</span></span><br><span class="line">    <span class="built_in">func</span>((<span class="type">int</span>)<span class="number">3.14</span>);  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征，也就是会发生多个函数匹配。同时，const变量（非const引用）不能作为函数重载的特征，与普通变量函数相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pass by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与第一个函数相同，编译报错。</span></span><br><span class="line"><span class="comment">void func(const int x) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;pass by const reference&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pass by non-const lvalue reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pass by const reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(a);    <span class="comment">// 报错，第一个与第二个函数都匹配</span></span><br><span class="line">    <span class="built_in">func</span>(b);    <span class="comment">// 报错，第一个与第三个函数都匹配</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">30</span>);   <span class="comment">// 报错，第一个与第三个函数都匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果重载函数有默认参数，调用的参数个数不足以明确唯一函数时，多个函数都可能匹配成功，编译器无法判断用哪个，就会报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int, int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// ❌ 编译报错：调用 func(10) 时匹配了两个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>内联函数（inline）在调用时，相当于将函数的代码“直接展开”到调用点处，提高程序运行的速度。<br><strong>语法：</strong> 在函数声明和定义前加上关键字inline。<br>通常的做法是将函数声明和定义写在一起。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>内联函数节省时间，但消耗内存。</li>
<li>如果函数过大，编译器可能不将其作为内联函数。</li>
<li>内联函数不能递归。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">square</span>(<span class="number">3</span>);  <span class="comment">// 真实调用时，会跳到 square 函数地址去执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">square</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 相当于 int y = 3 * 3;   编译器会直接替换，不发生跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/09/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/" data-id="cmdohx9hc000630w83726aaoy" data-title="函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/18/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%95%E7%94%A8/">引用</a>
          </li>
        
          <li>
            <a href="/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE/">枚举</a>
          </li>
        
          <li>
            <a href="/2025/07/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构与算法</a>
          </li>
        
          <li>
            <a href="/2025/07/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>
          </li>
        
          <li>
            <a href="/2025/06/29/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/">动态分配内存</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>